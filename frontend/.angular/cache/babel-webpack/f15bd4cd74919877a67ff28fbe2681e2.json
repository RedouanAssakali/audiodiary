{"ast":null,"code":"var isArray = require(\"x-is-array\");\n\nvar VPatch = require(\"../vnode/vpatch\");\n\nvar isVNode = require(\"../vnode/is-vnode\");\n\nvar isVText = require(\"../vnode/is-vtext\");\n\nvar isWidget = require(\"../vnode/is-widget\");\n\nvar isThunk = require(\"../vnode/is-thunk\");\n\nvar handleThunk = require(\"../vnode/handle-thunk\");\n\nvar diffProps = require(\"./diff-props\");\n\nmodule.exports = diff;\n\nfunction diff(a, b) {\n  var patch = {\n    a: a\n  };\n  walk(a, b, patch, 0);\n  return patch;\n}\n\nfunction walk(a, b, patch, index) {\n  if (a === b) {\n    return;\n  }\n\n  var apply = patch[index];\n  var applyClear = false;\n\n  if (isThunk(a) || isThunk(b)) {\n    thunks(a, b, patch, index);\n  } else if (b == null) {\n    // If a is a widget we will add a remove patch for it\n    // Otherwise any child widgets/hooks must be destroyed.\n    // This prevents adding two remove patches for a widget.\n    if (!isWidget(a)) {\n      clearState(a, patch, index);\n      apply = patch[index];\n    }\n\n    apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b));\n  } else if (isVNode(b)) {\n    if (isVNode(a)) {\n      if (a.tagName === b.tagName && a.namespace === b.namespace && a.key === b.key) {\n        var propsPatch = diffProps(a.properties, b.properties);\n\n        if (propsPatch) {\n          apply = appendPatch(apply, new VPatch(VPatch.PROPS, a, propsPatch));\n        }\n\n        apply = diffChildren(a, b, patch, apply, index);\n      } else {\n        apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));\n        applyClear = true;\n      }\n    } else {\n      apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));\n      applyClear = true;\n    }\n  } else if (isVText(b)) {\n    if (!isVText(a)) {\n      apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));\n      applyClear = true;\n    } else if (a.text !== b.text) {\n      apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));\n    }\n  } else if (isWidget(b)) {\n    if (!isWidget(a)) {\n      applyClear = true;\n    }\n\n    apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b));\n  }\n\n  if (apply) {\n    patch[index] = apply;\n  }\n\n  if (applyClear) {\n    clearState(a, patch, index);\n  }\n}\n\nfunction diffChildren(a, b, patch, apply, index) {\n  var aChildren = a.children;\n  var orderedSet = reorder(aChildren, b.children);\n  var bChildren = orderedSet.children;\n  var aLen = aChildren.length;\n  var bLen = bChildren.length;\n  var len = aLen > bLen ? aLen : bLen;\n\n  for (var i = 0; i < len; i++) {\n    var leftNode = aChildren[i];\n    var rightNode = bChildren[i];\n    index += 1;\n\n    if (!leftNode) {\n      if (rightNode) {\n        // Excess nodes in b need to be added\n        apply = appendPatch(apply, new VPatch(VPatch.INSERT, null, rightNode));\n      }\n    } else {\n      walk(leftNode, rightNode, patch, index);\n    }\n\n    if (isVNode(leftNode) && leftNode.count) {\n      index += leftNode.count;\n    }\n  }\n\n  if (orderedSet.moves) {\n    // Reorder nodes last\n    apply = appendPatch(apply, new VPatch(VPatch.ORDER, a, orderedSet.moves));\n  }\n\n  return apply;\n}\n\nfunction clearState(vNode, patch, index) {\n  // TODO: Make this a single walk, not two\n  unhook(vNode, patch, index);\n  destroyWidgets(vNode, patch, index);\n} // Patch records for all destroyed widgets must be added because we need\n// a DOM node reference for the destroy function\n\n\nfunction destroyWidgets(vNode, patch, index) {\n  if (isWidget(vNode)) {\n    if (typeof vNode.destroy === \"function\") {\n      patch[index] = appendPatch(patch[index], new VPatch(VPatch.REMOVE, vNode, null));\n    }\n  } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {\n    var children = vNode.children;\n    var len = children.length;\n\n    for (var i = 0; i < len; i++) {\n      var child = children[i];\n      index += 1;\n      destroyWidgets(child, patch, index);\n\n      if (isVNode(child) && child.count) {\n        index += child.count;\n      }\n    }\n  } else if (isThunk(vNode)) {\n    thunks(vNode, null, patch, index);\n  }\n} // Create a sub-patch for thunks\n\n\nfunction thunks(a, b, patch, index) {\n  var nodes = handleThunk(a, b);\n  var thunkPatch = diff(nodes.a, nodes.b);\n\n  if (hasPatches(thunkPatch)) {\n    patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch);\n  }\n}\n\nfunction hasPatches(patch) {\n  for (var index in patch) {\n    if (index !== \"a\") {\n      return true;\n    }\n  }\n\n  return false;\n} // Execute hooks when two nodes are identical\n\n\nfunction unhook(vNode, patch, index) {\n  if (isVNode(vNode)) {\n    if (vNode.hooks) {\n      patch[index] = appendPatch(patch[index], new VPatch(VPatch.PROPS, vNode, undefinedKeys(vNode.hooks)));\n    }\n\n    if (vNode.descendantHooks || vNode.hasThunks) {\n      var children = vNode.children;\n      var len = children.length;\n\n      for (var i = 0; i < len; i++) {\n        var child = children[i];\n        index += 1;\n        unhook(child, patch, index);\n\n        if (isVNode(child) && child.count) {\n          index += child.count;\n        }\n      }\n    }\n  } else if (isThunk(vNode)) {\n    thunks(vNode, null, patch, index);\n  }\n}\n\nfunction undefinedKeys(obj) {\n  var result = {};\n\n  for (var key in obj) {\n    result[key] = undefined;\n  }\n\n  return result;\n} // List diff, naive left to right reordering\n\n\nfunction reorder(aChildren, bChildren) {\n  // O(M) time, O(M) memory\n  var bChildIndex = keyIndex(bChildren);\n  var bKeys = bChildIndex.keys;\n  var bFree = bChildIndex.free;\n\n  if (bFree.length === bChildren.length) {\n    return {\n      children: bChildren,\n      moves: null\n    };\n  } // O(N) time, O(N) memory\n\n\n  var aChildIndex = keyIndex(aChildren);\n  var aKeys = aChildIndex.keys;\n  var aFree = aChildIndex.free;\n\n  if (aFree.length === aChildren.length) {\n    return {\n      children: bChildren,\n      moves: null\n    };\n  } // O(MAX(N, M)) memory\n\n\n  var newChildren = [];\n  var freeIndex = 0;\n  var freeCount = bFree.length;\n  var deletedItems = 0; // Iterate through a and match a node in b\n  // O(N) time,\n\n  for (var i = 0; i < aChildren.length; i++) {\n    var aItem = aChildren[i];\n    var itemIndex;\n\n    if (aItem.key) {\n      if (bKeys.hasOwnProperty(aItem.key)) {\n        // Match up the old keys\n        itemIndex = bKeys[aItem.key];\n        newChildren.push(bChildren[itemIndex]);\n      } else {\n        // Remove old keyed items\n        itemIndex = i - deletedItems++;\n        newChildren.push(null);\n      }\n    } else {\n      // Match the item in a with the next free item in b\n      if (freeIndex < freeCount) {\n        itemIndex = bFree[freeIndex++];\n        newChildren.push(bChildren[itemIndex]);\n      } else {\n        // There are no free items in b to match with\n        // the free items in a, so the extra free nodes\n        // are deleted.\n        itemIndex = i - deletedItems++;\n        newChildren.push(null);\n      }\n    }\n  }\n\n  var lastFreeIndex = freeIndex >= bFree.length ? bChildren.length : bFree[freeIndex]; // Iterate through b and append any new keys\n  // O(M) time\n\n  for (var j = 0; j < bChildren.length; j++) {\n    var newItem = bChildren[j];\n\n    if (newItem.key) {\n      if (!aKeys.hasOwnProperty(newItem.key)) {\n        // Add any new keyed items\n        // We are adding new items to the end and then sorting them\n        // in place. In future we should insert new items in place.\n        newChildren.push(newItem);\n      }\n    } else if (j >= lastFreeIndex) {\n      // Add any leftover non-keyed items\n      newChildren.push(newItem);\n    }\n  }\n\n  var simulate = newChildren.slice();\n  var simulateIndex = 0;\n  var removes = [];\n  var inserts = [];\n  var simulateItem;\n\n  for (var k = 0; k < bChildren.length;) {\n    var wantedItem = bChildren[k];\n    simulateItem = simulate[simulateIndex]; // remove items\n\n    while (simulateItem === null && simulate.length) {\n      removes.push(remove(simulate, simulateIndex, null));\n      simulateItem = simulate[simulateIndex];\n    }\n\n    if (!simulateItem || simulateItem.key !== wantedItem.key) {\n      // if we need a key in this position...\n      if (wantedItem.key) {\n        if (simulateItem && simulateItem.key) {\n          // if an insert doesn't put this key in place, it needs to move\n          if (bKeys[simulateItem.key] !== k + 1) {\n            removes.push(remove(simulate, simulateIndex, simulateItem.key));\n            simulateItem = simulate[simulateIndex]; // if the remove didn't put the wanted item in place, we need to insert it\n\n            if (!simulateItem || simulateItem.key !== wantedItem.key) {\n              inserts.push({\n                key: wantedItem.key,\n                to: k\n              });\n            } // items are matching, so skip ahead\n            else {\n              simulateIndex++;\n            }\n          } else {\n            inserts.push({\n              key: wantedItem.key,\n              to: k\n            });\n          }\n        } else {\n          inserts.push({\n            key: wantedItem.key,\n            to: k\n          });\n        }\n\n        k++;\n      } // a key in simulate has no matching wanted key, remove it\n      else if (simulateItem && simulateItem.key) {\n        removes.push(remove(simulate, simulateIndex, simulateItem.key));\n      }\n    } else {\n      simulateIndex++;\n      k++;\n    }\n  } // remove all the remaining nodes from simulate\n\n\n  while (simulateIndex < simulate.length) {\n    simulateItem = simulate[simulateIndex];\n    removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key));\n  } // If the only moves we have are deletes then we can just\n  // let the delete patch remove these items.\n\n\n  if (removes.length === deletedItems && !inserts.length) {\n    return {\n      children: newChildren,\n      moves: null\n    };\n  }\n\n  return {\n    children: newChildren,\n    moves: {\n      removes: removes,\n      inserts: inserts\n    }\n  };\n}\n\nfunction remove(arr, index, key) {\n  arr.splice(index, 1);\n  return {\n    from: index,\n    key: key\n  };\n}\n\nfunction keyIndex(children) {\n  var keys = {};\n  var free = [];\n  var length = children.length;\n\n  for (var i = 0; i < length; i++) {\n    var child = children[i];\n\n    if (child.key) {\n      keys[child.key] = i;\n    } else {\n      free.push(i);\n    }\n  }\n\n  return {\n    keys: keys,\n    // A hash of key name to index\n    free: free // An array of unkeyed item indices\n\n  };\n}\n\nfunction appendPatch(apply, patch) {\n  if (apply) {\n    if (isArray(apply)) {\n      apply.push(patch);\n    } else {\n      apply = [apply, patch];\n    }\n\n    return apply;\n  } else {\n    return patch;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}