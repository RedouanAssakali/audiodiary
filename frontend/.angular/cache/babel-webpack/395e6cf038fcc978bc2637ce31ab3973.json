{"ast":null,"code":"import { processLayer } from \"./transformationProcessing/processLayer.js\";\nimport { process_if } from \"./transformationProcessing/processIf.js\";\nimport { toArray } from \"./utils/toArray.js\";\nimport { processRadius } from \"./transformationProcessing/processRadius.js\";\nimport { isObject } from \"./utils/isObject.js\";\nimport { processCustomFunction } from \"./transformationProcessing/processCustomFunction.js\";\nimport { processCustomPreFunction } from \"./transformationProcessing/processCustomPreFunction.js\";\nimport { splitRange } from \"./utils/splitRange.js\";\nimport { legacyNormalizeExpression } from \"./utils/legacyNormalizeExpression.js\";\nimport { normRangeValues } from \"./utils/norm_range_values.js\";\nimport { processVideoParams } from \"./transformationProcessing/processVideoParams.js\";\nimport Transformation from \"./transformation.js\";\nimport { processDpr } from \"./transformationProcessing/processDpr.js\";\n/**\n * Things dropped\n * - responsive_width\n * - config().dpr\n * - SSL Detected\n * - Provisioning API\n * - Magical configuration auto-mapping (everything has to be explicit)\n * - Signatures\n * - Secure is default true\n * @param transformationOptions\n */\n\nexport function generateTransformationString(transformationOptions) {\n  if (typeof transformationOptions === 'string') {\n    return transformationOptions;\n  }\n\n  if (transformationOptions instanceof Transformation) {\n    return transformationOptions.toString();\n  }\n\n  if (Array.isArray(transformationOptions)) {\n    return transformationOptions.map(singleTransformation => {\n      return generateTransformationString(singleTransformation);\n    }).filter(a => {\n      return a;\n    }).join('/');\n  } // let responsive_width = consumeOption(transformationOptions, \"responsive_width\", config().responsive_width);\n\n\n  let width;\n  let height;\n  const size = transformationOptions.size;\n  const hasLayer = transformationOptions.overlay || transformationOptions.underlay;\n  const crop = transformationOptions.crop;\n  const angle = toArray(transformationOptions.angle).join(\".\");\n  const background = (transformationOptions.background || '').replace(/^#/, \"rgb:\");\n  const color = (transformationOptions.color || '').replace(/^#/, \"rgb:\");\n  const flags = toArray(transformationOptions.flags || []).join('.');\n  const dpr = transformationOptions.dpr === undefined ? transformationOptions.dpr : processDpr(transformationOptions.dpr);\n  const overlay = processLayer(transformationOptions.overlay);\n  const radius = processRadius(transformationOptions.radius);\n  const underlay = processLayer(transformationOptions.underlay);\n  const ifValue = process_if(transformationOptions.if);\n  const custom_function = processCustomFunction(transformationOptions.custom_function);\n  const custom_pre_function = processCustomPreFunction(transformationOptions.custom_pre_function); // These will change down the line, heads up!\n\n  let fps = transformationOptions.fps;\n  let namedTransformations = [];\n  let childTransformations = toArray(transformationOptions.transformation || []);\n  let effect = transformationOptions.effect; // TODO, Do we need this?\n\n  const no_html_sizes = hasLayer || angle || crop === \"fit\" || crop === \"limit\";\n\n  if (size) {\n    const [sizeWidth, sizeHeight] = size.split(\"x\");\n    width = sizeWidth;\n    height = sizeHeight;\n  } else {\n    width = transformationOptions.width;\n    height = transformationOptions.height;\n  }\n\n  if (width && (width.toString().indexOf(\"auto\") === 0 || no_html_sizes || parseFloat(width.toString()) < 1)) {\n    delete transformationOptions.width;\n  }\n\n  if (height && (no_html_sizes || parseFloat(height.toString()) < 1)) {\n    delete transformationOptions.height;\n  } // Is any child transformation an object?\n\n\n  const isAnyChildAnObject = childTransformations.some(transformation => typeof transformation === 'object'); // If array of objects, or array of strings?\n\n  if (isAnyChildAnObject) {\n    childTransformations = childTransformations.map(transformation => {\n      if (isObject(transformation)) {\n        return generateTransformationString(transformation);\n      } else {\n        return generateTransformationString({\n          transformation\n        });\n      }\n    }).filter(a => a);\n  } else {\n    namedTransformations = childTransformations.join(\".\");\n    childTransformations = []; // Reset child transfomrations\n  }\n\n  if (Array.isArray(effect)) {\n    effect = effect.join(\":\");\n  } else if (isObject(effect)) {\n    effect = Object.entries(effect).map(([key, value]) => `${key}:${value}`);\n  }\n\n  let border = transformationOptions.border;\n\n  if (isObject(border)) {\n    border = `${border.width != null ? border.width : 2}px_solid_${(border.color != null ? border.color : \"black\").replace(/^#/, 'rgb:')}`;\n  } else {\n    // @ts-ignore\n    if (/^\\d+$/.exec(border)) {\n      // fallback to html border attributes\n      transformationOptions.border = border;\n      border = void 0;\n    }\n  }\n\n  if (Array.isArray(fps)) {\n    fps = fps.join('-');\n  } // ocr(value) {\n  //   return this.param(value, \"ocr\", \"ocr\");\n  // }\n\n\n  const urlParams = {\n    a: legacyNormalizeExpression(angle),\n    ar: legacyNormalizeExpression(transformationOptions.aspect_ratio),\n    b: background,\n    bo: border,\n    c: crop,\n    co: color,\n    dpr: legacyNormalizeExpression(dpr),\n    e: legacyNormalizeExpression(effect),\n    fl: flags,\n    fn: custom_function || custom_pre_function,\n    fps: fps,\n    h: legacyNormalizeExpression(height),\n    ki: legacyNormalizeExpression(transformationOptions.keyframe_interval),\n    l: overlay,\n    o: legacyNormalizeExpression(transformationOptions.opacity),\n    q: legacyNormalizeExpression(transformationOptions.quality),\n    r: radius,\n    t: namedTransformations,\n    u: underlay,\n    w: legacyNormalizeExpression(width),\n    x: legacyNormalizeExpression(transformationOptions.x),\n    y: legacyNormalizeExpression(transformationOptions.y),\n    z: legacyNormalizeExpression(transformationOptions.zoom),\n    ac: transformationOptions.audio_codec,\n    af: transformationOptions.audio_frequency,\n    br: transformationOptions.bit_rate,\n    cs: transformationOptions.color_space,\n    d: transformationOptions.default_image,\n    dl: transformationOptions.delay,\n    dn: transformationOptions.density,\n    du: normRangeValues(transformationOptions.duration),\n    eo: normRangeValues(splitRange(transformationOptions.offset)[1]),\n    f: transformationOptions.fetch_format,\n    g: transformationOptions.gravity,\n    pg: transformationOptions.page,\n    p: transformationOptions.prefix,\n    so: normRangeValues(splitRange(transformationOptions.offset)[0]),\n    sp: transformationOptions.streaming_profile,\n    vc: processVideoParams(transformationOptions.video_codec),\n    vs: transformationOptions.video_sampling\n  }; // We can accept variables in here transformationOptions, or in here transformationOptions.variables\n\n  const variables = Object.entries(transformationOptions).filter(([key, value]) => key.startsWith('$')).map(([key, value]) => {\n    // delete transformationOptions[key]; // Delete the variables, so we don't add them twice\n    return `${key}_${legacyNormalizeExpression(value)}`;\n  }).sort().concat( // @ts-ignore\n  (transformationOptions.variables || []).map(([name, value]) => `${name}_${legacyNormalizeExpression(value)}`)).join(','); // Clean up!\n\n  const urlImageTransfomrations = Object.entries(urlParams).filter(([key, value]) => {\n    if (typeof value === 'undefined' || value === null) {\n      return false;\n    }\n\n    if (typeof value === 'string' && value.length === 0) {\n      return false;\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false;\n    }\n\n    return true;\n  }).map(([key, value]) => `${key}_${value}`).sort().join(',');\n  const finalTransformationString = [ifValue, variables, urlImageTransfomrations, transformationOptions.raw_transformation].filter(a => a).join(\",\");\n\n  if (finalTransformationString) {\n    childTransformations.push(finalTransformationString);\n  } // console.log(childTransformations);\n\n\n  return childTransformations.join(\"/\");\n}","map":null,"metadata":{},"sourceType":"module"}