{"ast":null,"code":"import { getUrlPrefix, getUrlVersion, handleAssetType, handleDeliveryType } from \"../internal/url/cloudinaryURL.js\";\nimport URLConfig from \"../config/URLConfig.js\";\nimport { getSDKAnalyticsSignature } from \"../sdkAnalytics/getSDKAnalyticsSignature.js\";\n/**\n * This const contains all the valid combination of asset/delivery for URL shortening purposes\n * It's exported because it's used in a test, but it's not really shared enough to belong in a separate file\n */\n\nexport const SEO_TYPES = {\n  \"image/upload\": \"images\",\n  \"image/private\": \"private_images\",\n  \"image/authenticated\": \"authenticated_images\",\n  \"raw/upload\": \"files\",\n  \"video/upload\": \"videos\"\n};\n/**\n * @description Cloudinary file without a transformation\n * @summary SDK\n * @memberOf SDK\n */\n\nclass CloudinaryFile {\n  constructor(publicID, cloudConfig = {}, urlConfig) {\n    this.setPublicID(publicID);\n    this.setCloudConfig(cloudConfig);\n    this.setURLConfig(urlConfig);\n  }\n  /**\n   * @description Sets the URL Config for this asset\n   * @param urlConfig\n   * @return {this}\n   */\n\n\n  setURLConfig(urlConfig) {\n    this.urlConfig = new URLConfig(urlConfig);\n    return this;\n  }\n  /**\n   * @description Sets the Cloud Config for this asset\n   * @param urlConfig\n   * @return {this}\n   */\n\n\n  setCloudConfig(cloudConfig) {\n    this.cloudName = cloudConfig.cloudName;\n    this.apiKey = cloudConfig.apiKey;\n    this.apiSecret = cloudConfig.apiSecret;\n    this.authToken = cloudConfig.authToken;\n    return this;\n  }\n  /**\n   * @description Sets the public ID of the asset.\n   * @param {string} publicID The public ID of the asset.\n   * @return {this}\n   */\n\n\n  setPublicID(publicID) {\n    // PublicID must be a string!\n    this.publicID = publicID ? publicID.toString() : '';\n    return this;\n  }\n  /**\n   * @description Sets the delivery type of the asset.\n   * @param {DELIVERY_TYPE | string} newType The type of the asset.\n   * @return {this}\n   */\n\n\n  setDeliveryType(newType) {\n    this.deliveryType = newType;\n    return this;\n  }\n  /**\n   * @description Sets the URL SEO suffix of the asset.\n   * @param {string} newSuffix The SEO suffix.\n   * @return {this}\n   */\n\n\n  setSuffix(newSuffix) {\n    this.suffix = newSuffix;\n    return this;\n  }\n  /**\n   * @description Sets the signature of the asset.\n   * @param {string} signature The signature.\n   * @return {this}\n   */\n\n\n  setSignature(signature) {\n    this.signature = signature;\n    return this;\n  }\n  /**\n   * @description Sets the version of the asset.\n   * @param {string} newVersion The version of the asset.\n   * @return {this}\n   */\n\n\n  setVersion(newVersion) {\n    if (newVersion) {\n      this.version = newVersion;\n    }\n\n    return this;\n  }\n  /**\n   * @description Sets the asset type.\n   * @param {string} newType The type of the asset.\n   * @return {this}\n   */\n\n\n  setAssetType(newType) {\n    if (newType) {\n      this.assetType = newType;\n    }\n\n    return this;\n  }\n\n  sign() {\n    return this;\n  }\n  /**\n   * @description Serializes to URL string\n   * @param overwriteOptions\n   */\n\n\n  toURL(overwriteOptions = {}) {\n    return this.createCloudinaryURL(null, overwriteOptions.trackedAnalytics);\n  }\n  /**\n   * @description Validate various options before attempting to create a URL\n   * The function will throw in case a violation\n   * @throws Validation errors\n   */\n\n\n  validateAssetForURLCreation() {\n    if (typeof this.cloudName === 'undefined') {\n      throw 'You must supply a cloudName when initializing the asset';\n    }\n\n    const suffixContainsDot = this.suffix && this.suffix.indexOf('.') >= 0;\n    const suffixContainsSlash = this.suffix && this.suffix.indexOf('/') >= 0;\n\n    if (suffixContainsDot || suffixContainsSlash) {\n      throw '`suffix`` should not include . or /';\n    }\n  }\n  /**\n   * @description return an SEO friendly name for a combination of asset/delivery, some examples:\n   * * image/upload -> images\n   * * video/upload -> videos\n   * If no match is found, return `{asset}/{delivery}`\n   */\n\n\n  getResourceType() {\n    const assetType = handleAssetType(this.assetType);\n    const deliveryType = handleDeliveryType(this.deliveryType);\n    const hasSuffix = !!this.suffix;\n    const regularSEOType = `${assetType}/${deliveryType}`;\n    const shortSEOType = SEO_TYPES[`${assetType}/${deliveryType}`];\n    const useRootPath = this.urlConfig.useRootPath;\n    const shorten = this.urlConfig.shorten; // Quick exit incase of useRootPath\n\n    if (useRootPath) {\n      if (regularSEOType === 'image/upload') {\n        return ''; // For image/upload we're done, just return nothing\n      } else {\n        throw new Error(`useRootPath can only be used with assetType: 'image' and deliveryType: 'upload'. Provided: ${regularSEOType} instead`);\n      }\n    }\n\n    if (shorten && regularSEOType === 'image/upload') {\n      return 'iu';\n    }\n\n    if (hasSuffix) {\n      if (shortSEOType) {\n        return shortSEOType;\n      } else {\n        throw new Error(`URL Suffix only supported for ${Object.keys(SEO_TYPES).join(', ')}, Provided: ${regularSEOType} instead`);\n      }\n    } // If all else fails, return the regular image/upload combination (asset/delivery)\n\n\n    return regularSEOType;\n  }\n\n  getSignature() {\n    if (this.signature) {\n      return `s--${this.signature}--`;\n    } else {\n      return '';\n    }\n  }\n  /**\n   *\n   * @description Creates a fully qualified CloudinaryURL\n   * @return {string} CloudinaryURL\n   * @throws Validation Errors\n   */\n\n\n  createCloudinaryURL(transformation, trackedAnalytics) {\n    // In accordance with the existing implementation, if no publicID exists we should return nothing.\n    if (!this.publicID) {\n      return '';\n    } // Throws if some options are mis-configured\n    // See the function for more information on when it throws\n\n\n    this.validateAssetForURLCreation();\n    const prefix = getUrlPrefix(this.cloudName, this.urlConfig);\n    const transformationString = transformation ? transformation.toString() : '';\n    const version = getUrlVersion(this.publicID, this.version, this.urlConfig.forceVersion);\n    const publicID = this.publicID // Serialize the publicID, but leave slashes alone.\n    // we can't use serializeCloudinaryCharacters because that does both things (, and /)\n    .replace(/,/g, '%2C'); // Resource type is a mixture of assetType, deliveryType and various URL Configurations\n    // Note how `suffix` changes both image/upload (resourceType) and also is appended at the end\n\n    const url = [prefix, this.getResourceType(), this.getSignature(), transformationString, version, publicID, this.suffix].filter(a => a).join('/');\n\n    if (typeof transformation === 'string') {\n      return url;\n    } else {\n      const safeURL = encodeURI(url).replace(/\\?/g, '%3F').replace(/=/g, '%3D'); // urlConfig.analytics is true by default, has to be explicitly set to false to overwrite\n      // Don't add analytics when publicId includes a '?' to not risk changing existing query params\n\n      if (this.urlConfig.analytics !== false && !publicID.includes('?')) {\n        return `${safeURL}?_a=${getSDKAnalyticsSignature(trackedAnalytics)}`;\n      } else {\n        return safeURL;\n      }\n    }\n  }\n\n}\n\nexport { CloudinaryFile };","map":null,"metadata":{},"sourceType":"module"}