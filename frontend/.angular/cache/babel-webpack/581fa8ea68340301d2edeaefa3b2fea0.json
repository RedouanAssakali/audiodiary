{"ast":null,"code":"export default function () {\n  // http://jsperf.com/typed-array-min-max/2\n  // plain for loop for finding min/max is way faster than anything else.\n\n  /**\n   * @param {TypedArray} array - Subarray of audio to calculate peaks from.\n   */\n  function findMinMax(array) {\n    let min = Infinity;\n    let max = -Infinity;\n    let curr;\n\n    for (let i = 0; i < array.length; i += 1) {\n      curr = array[i];\n\n      if (min > curr) {\n        min = curr;\n      }\n\n      if (max < curr) {\n        max = curr;\n      }\n    }\n\n    return {\n      min,\n      max\n    };\n  }\n  /**\n   * @param {Number} n - peak to convert from float to Int8, Int16 etc.\n   * @param {Number} bits - convert to #bits two's complement signed integer\n   */\n\n\n  function convert(n, bits) {\n    const max = 2 ** (bits - 1);\n    const v = n < 0 ? n * max : n * max - 1;\n    return Math.max(-max, Math.min(max - 1, v));\n  }\n  /**\n   * @param {TypedArray} channel - Audio track frames to calculate peaks from.\n   * @param {Number} samplesPerPixel - Audio frames per peak\n   */\n\n\n  function extractPeaks(channel, samplesPerPixel, bits) {\n    const chanLength = channel.length;\n    const numPeaks = Math.ceil(chanLength / samplesPerPixel);\n    let start;\n    let end;\n    let segment;\n    let max;\n    let min;\n    let extrema; // create interleaved array of min,max\n\n    const peaks = new self[`Int${bits}Array`](numPeaks * 2);\n\n    for (let i = 0; i < numPeaks; i += 1) {\n      start = i * samplesPerPixel;\n      end = (i + 1) * samplesPerPixel > chanLength ? chanLength : (i + 1) * samplesPerPixel;\n      segment = channel.subarray(start, end);\n      extrema = findMinMax(segment);\n      min = convert(extrema.min, bits);\n      max = convert(extrema.max, bits);\n      peaks[i * 2] = min;\n      peaks[i * 2 + 1] = max;\n    }\n\n    return peaks;\n  }\n  /**\n   * @param {TypedArray} source - Source of audio samples for peak calculations.\n   * @param {Number} samplesPerPixel - Number of audio samples per peak.\n   * @param {Number} cueIn - index in channel to start peak calculations from.\n   * @param {Number} cueOut - index in channel to end peak calculations from (non-inclusive).\n   */\n\n\n  function audioPeaks(source, samplesPerPixel = 10000, bits = 8) {\n    if ([8, 16, 32].indexOf(bits) < 0) {\n      throw new Error(\"Invalid number of bits specified for peaks.\");\n    }\n\n    const peaks = [];\n    const start = 0;\n    const end = source.length;\n    peaks.push(extractPeaks(source.subarray(start, end), samplesPerPixel, bits));\n    const length = peaks[0].length / 2;\n    return {\n      bits,\n      length,\n      data: peaks\n    };\n  }\n\n  onmessage = function onmessage(e) {\n    const peaks = audioPeaks(e.data.samples, e.data.samplesPerPixel);\n    postMessage(peaks);\n  };\n}","map":null,"metadata":{},"sourceType":"module"}