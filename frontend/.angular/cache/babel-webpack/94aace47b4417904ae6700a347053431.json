{"ast":null,"code":"export default function () {\n  let recLength = 0;\n  let recBuffersL = [];\n  let recBuffersR = [];\n  let sampleRate;\n\n  function init(config) {\n    sampleRate = config.sampleRate;\n  }\n\n  function record(inputBuffer) {\n    recBuffersL.push(inputBuffer[0]);\n    recBuffersR.push(inputBuffer[1]);\n    recLength += inputBuffer[0].length;\n  }\n\n  function writeString(view, offset, string) {\n    for (let i = 0; i < string.length; i += 1) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  }\n\n  function floatTo16BitPCM(output, offset, input) {\n    let writeOffset = offset;\n\n    for (let i = 0; i < input.length; i += 1, writeOffset += 2) {\n      const s = Math.max(-1, Math.min(1, input[i]));\n      output.setInt16(writeOffset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n  }\n\n  function encodeWAV(samples, mono = false) {\n    const buffer = new ArrayBuffer(44 + samples.length * 2);\n    const view = new DataView(buffer);\n    /* RIFF identifier */\n\n    writeString(view, 0, \"RIFF\");\n    /* file length */\n\n    view.setUint32(4, 32 + samples.length * 2, true);\n    /* RIFF type */\n\n    writeString(view, 8, \"WAVE\");\n    /* format chunk identifier */\n\n    writeString(view, 12, \"fmt \");\n    /* format chunk length */\n\n    view.setUint32(16, 16, true);\n    /* sample format (raw) */\n\n    view.setUint16(20, 1, true);\n    /* channel count */\n\n    view.setUint16(22, mono ? 1 : 2, true);\n    /* sample rate */\n\n    view.setUint32(24, sampleRate, true);\n    /* byte rate (sample rate * block align) */\n\n    view.setUint32(28, sampleRate * 4, true);\n    /* block align (channel count * bytes per sample) */\n\n    view.setUint16(32, 4, true);\n    /* bits per sample */\n\n    view.setUint16(34, 16, true);\n    /* data chunk identifier */\n\n    writeString(view, 36, \"data\");\n    /* data chunk length */\n\n    view.setUint32(40, samples.length * 2, true);\n    floatTo16BitPCM(view, 44, samples);\n    return view;\n  }\n\n  function mergeBuffers(recBuffers, length) {\n    const result = new Float32Array(length);\n    let offset = 0;\n\n    for (let i = 0; i < recBuffers.length; i += 1) {\n      result.set(recBuffers[i], offset);\n      offset += recBuffers[i].length;\n    }\n\n    return result;\n  }\n\n  function interleave(inputL, inputR) {\n    const length = inputL.length + inputR.length;\n    const result = new Float32Array(length);\n    let index = 0;\n    let inputIndex = 0;\n\n    while (index < length) {\n      result[index += 1] = inputL[inputIndex];\n      result[index += 1] = inputR[inputIndex];\n      inputIndex += 1;\n    }\n\n    return result;\n  }\n\n  function exportWAV(type) {\n    const bufferL = mergeBuffers(recBuffersL, recLength);\n    const bufferR = mergeBuffers(recBuffersR, recLength);\n    const interleaved = interleave(bufferL, bufferR);\n    const dataview = encodeWAV(interleaved);\n    const audioBlob = new Blob([dataview], {\n      type\n    });\n    postMessage(audioBlob);\n  }\n\n  function clear() {\n    recLength = 0;\n    recBuffersL = [];\n    recBuffersR = [];\n  }\n\n  onmessage = function onmessage(e) {\n    switch (e.data.command) {\n      case \"init\":\n        {\n          init(e.data.config);\n          break;\n        }\n\n      case \"record\":\n        {\n          record(e.data.buffer);\n          break;\n        }\n\n      case \"exportWAV\":\n        {\n          exportWAV(e.data.type);\n          break;\n        }\n\n      case \"clear\":\n        {\n          clear();\n          break;\n        }\n\n      default:\n        {\n          throw new Error(\"Unknown export worker command\");\n        }\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}