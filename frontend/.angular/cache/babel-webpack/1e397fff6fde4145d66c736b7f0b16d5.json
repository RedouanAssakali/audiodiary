{"ast":null,"code":"\"use strict\";\n/**\n * @param {TypedArray} array - Subarray of audio to calculate peaks from.\n */\n\nfunction findMinMax(array) {\n  var min = Infinity;\n  var max = -Infinity;\n  var i = 0;\n  var len = array.length;\n  var curr;\n\n  for (; i < len; i++) {\n    curr = array[i];\n\n    if (min > curr) {\n      min = curr;\n    }\n\n    if (max < curr) {\n      max = curr;\n    }\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n/**\n * @param {Number} n - peak to convert from float to Int8, Int16 etc.\n * @param {Number} bits - convert to #bits two's complement signed integer\n */\n\n\nfunction convert(n, bits) {\n  var max = Math.pow(2, bits - 1);\n  var v = n < 0 ? n * max : n * (max - 1);\n  return Math.max(-max, Math.min(max - 1, v));\n}\n/**\n * @param {TypedArray} channel - Audio track frames to calculate peaks from.\n * @param {Number} samplesPerPixel - Audio frames per peak\n */\n\n\nfunction extractPeaks(channel, samplesPerPixel, bits) {\n  var i;\n  var chanLength = channel.length;\n  var numPeaks = Math.ceil(chanLength / samplesPerPixel);\n  var start;\n  var end;\n  var segment;\n  var max;\n  var min;\n  var extrema; //create interleaved array of min,max\n\n  var peaks = makeTypedArray(bits, numPeaks * 2);\n\n  for (i = 0; i < numPeaks; i++) {\n    start = i * samplesPerPixel;\n    end = (i + 1) * samplesPerPixel > chanLength ? chanLength : (i + 1) * samplesPerPixel;\n    segment = channel.subarray(start, end);\n    extrema = findMinMax(segment);\n    min = convert(extrema.min, bits);\n    max = convert(extrema.max, bits);\n    peaks[i * 2] = min;\n    peaks[i * 2 + 1] = max;\n  }\n\n  return peaks;\n}\n\nfunction makeTypedArray(bits, length) {\n  return new (new Function(`return Int${bits}Array`)())(length);\n}\n\nfunction makeMono(channelPeaks, bits) {\n  var numChan = channelPeaks.length;\n  var weight = 1 / numChan;\n  var numPeaks = channelPeaks[0].length / 2;\n  var c = 0;\n  var i = 0;\n  var min;\n  var max;\n  var peaks = makeTypedArray(bits, numPeaks * 2);\n\n  for (i = 0; i < numPeaks; i++) {\n    min = 0;\n    max = 0;\n\n    for (c = 0; c < numChan; c++) {\n      min += weight * channelPeaks[c][i * 2];\n      max += weight * channelPeaks[c][i * 2 + 1];\n    }\n\n    peaks[i * 2] = min;\n    peaks[i * 2 + 1] = max;\n  } //return in array so channel number counts still work.\n\n\n  return [peaks];\n}\n\nfunction defaultNumber(value, defaultNumber) {\n  if (typeof value === \"number\") {\n    return value;\n  } else {\n    return defaultNumber;\n  }\n}\n/**\n * @param {AudioBuffer,TypedArray} source - Source of audio samples for peak calculations.\n * @param {Number} samplesPerPixel - Number of audio samples per peak.\n * @param {Boolean} isMono - Whether to render the channels to a single array.\n * @param {Number} cueIn - index in channel to start peak calculations from.\n * @param {Number} cueOut - index in channel to end peak calculations from (non-inclusive).\n * @param {Number} bits - number of bits for a peak.\n */\n\n\nmodule.exports = function (source, samplesPerPixel, isMono, cueIn, cueOut, bits) {\n  samplesPerPixel = defaultNumber(samplesPerPixel, 1000);\n  bits = defaultNumber(bits, 16);\n\n  if (isMono === null || isMono === undefined) {\n    isMono = true;\n  }\n\n  if ([8, 16, 32].indexOf(bits) < 0) {\n    throw new Error(\"Invalid number of bits specified for peaks.\");\n  }\n\n  var numChan = source.numberOfChannels;\n  var peaks = [];\n  var c;\n  var numPeaks;\n  var channel;\n  var slice;\n  cueIn = defaultNumber(cueIn, 0);\n  cueOut = defaultNumber(cueOut, source.length);\n\n  if (typeof source.subarray === \"undefined\") {\n    for (c = 0; c < numChan; c++) {\n      channel = source.getChannelData(c);\n      slice = channel.subarray(cueIn, cueOut);\n      peaks.push(extractPeaks(slice, samplesPerPixel, bits));\n    }\n  } else {\n    peaks.push(extractPeaks(source.subarray(cueIn, cueOut), samplesPerPixel, bits));\n  }\n\n  if (isMono && peaks.length > 1) {\n    peaks = makeMono(peaks, bits);\n  }\n\n  numPeaks = peaks[0].length / 2;\n  return {\n    length: numPeaks,\n    data: peaks,\n    bits: bits\n  };\n};","map":null,"metadata":{},"sourceType":"script"}