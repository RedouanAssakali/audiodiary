{"ast":null,"code":"import Condition from './condition.js';\nimport { CONFIG_PARAMS } from './configuration.js';\nimport { cloneDeep } from '../internal/utils/cloneDeep.js';\nimport { camelCase, contains, difference } from \"./utils/legacyBaseUtil.js\";\nimport { snakeCase } from \"./utils/snakeCase.js\";\nimport Expression from './expression.js';\nimport Layer from './legacyLayer/layer.js';\nimport TextLayer from './legacyLayer/textlayer.js';\nimport SubtitlesLayer from './legacyLayer/subtitleslayer.js';\nimport FetchLayer from './legacyLayer/fetchlayer.js';\nimport { isObject } from \"./utils/isObject.js\";\nimport { isString } from \"../internal/utils/dataStructureUtils.js\";\nimport { isEmpty } from \"./utils/isEmpty.js\";\nimport { isFunction } from \"./utils/isFunction.js\";\nimport { identity, withCamelCaseKeys } from \"./utils/legacyBaseUtil.js\";\n/**\n * A list of keys used by the url() function.\n * @private\n */\n\nexport const URL_KEYS = ['accessibility', 'api_secret', 'auth_token', 'cdn_subdomain', 'cloud_name', 'cname', 'format', 'placeholder', 'private_cdn', 'resource_type', 'secure', 'secure_cdn_subdomain', 'secure_distribution', 'shorten', 'sign_url', 'signature', 'ssl_detected', 'type', 'url_suffix', 'use_root_path', 'version'];\n/**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */\n\nfunction assignNotNull(target, ...sources) {\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      // @ts-ignore\n      if (source[key] != null) {\n        // @ts-ignore\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n}\n/**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */\n\n\nconst allStrings = function (list) {\n  return list.length && list.every(isString);\n};\n/**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */\n\n\nclass Param {\n  /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */\n  constructor(name, shortName, process = identity) {\n    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */\n    this.name = name;\n    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */\n\n    this.shortName = shortName;\n    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */\n\n    this.process = process;\n  }\n  /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */\n\n\n  set(origValue) {\n    this.origValue = origValue;\n    return this;\n  }\n  /**\n   * Generate the serialized form of the parameter\n   * @function Param#serialize\n   * @return {string} the serialized form of the parameter\n   */\n\n\n  serialize() {\n    var val, valid;\n    val = this.value();\n    valid = Array.isArray(val) || isObject(val) || isString(val) ? !isEmpty(val) : val != null;\n\n    if (this.shortName != null && valid) {\n      return `${this.shortName}_${val}`;\n    } else {\n      return '';\n    }\n  }\n  /**\n   * Return the processed value of the parameter\n   * @function Param#value\n   */\n\n\n  value() {\n    return this.process(this.origValue);\n  }\n\n  static norm_color(value) {\n    return value != null ? value.replace(/^#/, 'rgb:') : void 0;\n  }\n\n  static build_array(arg) {\n    if (arg == null) {\n      return [];\n    } else if (Array.isArray(arg)) {\n      return arg;\n    } else {\n      return [arg];\n    }\n  }\n  /**\n   * Covert value to video codec string.\n   *\n   * If the parameter is an object,\n   * @param {(string|Object)} param - the video codec as either a String or a Hash\n   * @return {string} the video codec string in the format codec:profile:level\n   * @example\n   * vc_[ :profile : [level]]\n   * or\n   { codec: 'h264', profile: 'basic', level: '3.1' }\n   * @ignore\n   */\n\n\n  static process_video_params(param) {\n    var video;\n\n    switch (param.constructor) {\n      case Object:\n        video = \"\";\n\n        if ('codec' in param) {\n          video = param.codec;\n\n          if ('profile' in param) {\n            video += \":\" + param.profile;\n\n            if ('level' in param) {\n              video += \":\" + param.level;\n            }\n          }\n        }\n\n        return video;\n\n      case String:\n        return param;\n\n      default:\n        return null;\n    }\n  }\n\n}\n\nclass ArrayParam extends Param {\n  /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name, shortName, sep = '.', process = undefined) {\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n\n  serialize() {\n    if (this.shortName != null) {\n      let arrayValue = this.value();\n\n      if (isEmpty(arrayValue)) {\n        return '';\n      } else if (isString(arrayValue)) {\n        return `${this.shortName}_${arrayValue}`;\n      } else {\n        let flat = arrayValue.map(t => isFunction(t.serialize) ? t.serialize() : t).join(this.sep);\n        return `${this.shortName}_${flat}`;\n      }\n    } else {\n      return '';\n    }\n  }\n\n  value() {\n    if (Array.isArray(this.origValue)) {\n      return this.origValue.map(v => this.process(v));\n    } else {\n      return this.process(this.origValue);\n    }\n  }\n\n  set(origValue) {\n    if (origValue == null || Array.isArray(origValue)) {\n      return super.set(origValue);\n    } else {\n      return super.set([origValue]);\n    }\n  }\n\n}\n\nclass TransformationParam extends Param {\n  /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name, shortName = \"t\", sep = '.', process = undefined) {\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n  /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */\n\n\n  serialize() {\n    let result = '';\n    const val = this.value();\n\n    if (isEmpty(val)) {\n      return result;\n    } // val is an array of strings so join them\n\n\n    if (allStrings(val)) {\n      const joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n\n      if (!isEmpty(joined)) {\n        // in case options.transformation was not set with an empty string (val != ['']);\n        result = `${this.shortName}_${joined}`;\n      }\n    } else {\n      // Convert val to an array of strings\n      result = val.map(t => {\n        if (isString(t) && !isEmpty(t)) {\n          return `${this.shortName}_${t}`;\n        }\n\n        if (isFunction(t.serialize)) {\n          return t.serialize();\n        }\n\n        if (isObject(t) && !isEmpty(t)) {\n          return new Transformation(t).serialize();\n        }\n\n        return undefined;\n      }).filter(t => t);\n    }\n\n    return result;\n  }\n\n  set(origValue1) {\n    this.origValue = origValue1;\n\n    if (Array.isArray(this.origValue)) {\n      return super.set(this.origValue);\n    } else {\n      return super.set([this.origValue]);\n    }\n  }\n\n}\n\nconst number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\nconst offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n\nclass RangeParam extends Param {\n  /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name, shortName, process = RangeParam.norm_range_value) {\n    super(name, shortName, process);\n  }\n\n  static norm_range_value(value) {\n    let offset = String(value).match(new RegExp('^' + offset_any_pattern + '$'));\n\n    if (offset) {\n      let modifier = offset[5] != null ? 'p' : '';\n      value = (offset[1] || offset[4]) + modifier;\n    }\n\n    return value;\n  }\n\n}\n\nclass RawParam extends Param {\n  constructor(name, shortName, process = identity) {\n    super(name, shortName, process);\n  }\n\n  serialize() {\n    return this.value();\n  }\n\n}\n\nclass LayerParam extends Param {\n  // Parse layer options\n  // @return [string] layer transformation string\n  // @private\n  value() {\n    if (this.origValue == null) {\n      return '';\n    }\n\n    let result;\n\n    if (this.origValue instanceof Layer) {\n      result = this.origValue;\n    } else if (isObject(this.origValue)) {\n      let layerOptions = withCamelCaseKeys(this.origValue); // @ts-ignore\n\n      if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n        result = new TextLayer(layerOptions);\n      } else {\n        // @ts-ignore\n        if (layerOptions.resourceType === \"subtitles\") {\n          result = new SubtitlesLayer(layerOptions);\n        } else {\n          // @ts-ignore\n          if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n            result = new FetchLayer(layerOptions);\n          } else {\n            result = new Layer(layerOptions);\n          }\n        }\n      }\n    } else if (isString(this.origValue)) {\n      if (/^fetch:.+/.test(this.origValue)) {\n        result = new FetchLayer(this.origValue.substr(6));\n      } else {\n        result = this.origValue;\n      }\n    } else {\n      result = '';\n    }\n\n    return result.toString();\n  }\n\n  static textStyle(layer) {\n    return new TextLayer(layer).textStyleIdentifier();\n  }\n\n}\n/**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */\n\n\nclass TransformationBase {\n  /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */\n  constructor(options) {\n    /** @private */\n\n    /** @private */\n    let parent;\n    let trans;\n    parent = void 0;\n    trans = {};\n    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */\n\n    this.toOptions = withChain => {\n      let opt = {};\n\n      if (withChain == null) {\n        withChain = true;\n      } // @ts-ignore\n\n\n      Object.keys(trans).forEach(key => opt[key] = trans[key].origValue);\n      assignNotNull(opt, this.otherOptions);\n\n      if (withChain && !isEmpty(this.chained)) {\n        let list = this.chained.map(tr => tr.toOptions());\n        list.push(opt);\n        opt = {};\n        assignNotNull(opt, this.otherOptions); // @ts-ignore\n\n        opt.transformation = list;\n      }\n\n      return opt;\n    };\n    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */\n\n\n    this.setParent = object => {\n      parent = object;\n\n      if (object != null) {\n        // @ts-ignore\n        this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n      }\n\n      return this;\n    };\n    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */\n\n\n    this.getParent = () => {\n      return parent;\n    }; // Helper methods to create parameter methods\n    // These methods are defined here because they access `trans` which is\n    // a private member of `TransformationBase`\n\n    /** @protected */\n\n\n    this.param = (value, name, abbr, defaultValue, process) => {\n      if (process == null) {\n        if (isFunction(defaultValue)) {\n          process = defaultValue;\n        } else {\n          process = identity;\n        }\n      } // @ts-ignore\n\n\n      trans[name] = new Param(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.rawParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new RawParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.rangeParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new RangeParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.arrayParam = function (value, name, abbr, sep = \":\", defaultValue = [], process = undefined) {\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new ArrayParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n    /** @protected */\n\n\n    this.transformationParam = function (value, name, abbr, sep = \".\", defaultValue = undefined, process = undefined) {\n      process = lastArgCallback(arguments); // @ts-ignore\n\n      trans[name] = new TransformationParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n\n    this.layerParam = function (value, name, abbr) {\n      // @ts-ignore\n      trans[name] = new LayerParam(name, abbr).set(value);\n      return this;\n    }; // End Helper methods\n\n    /**\n     * Get the value associated with the given name.\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */\n\n\n    this.getValue = function (name) {\n      // @ts-ignore\n      let value = trans[name] && trans[name].value();\n      return value != null ? value : this.otherOptions[name];\n    };\n    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */\n\n\n    this.get = function (name) {\n      // @ts-ignore\n      return trans[name];\n    };\n    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */\n\n\n    this.remove = function (name) {\n      var temp;\n\n      switch (false) {\n        // @ts-ignore\n        case trans[name] == null:\n          // @ts-ignore\n          temp = trans[name]; // @ts-ignore\n\n          delete trans[name];\n          return temp.origValue;\n\n        case this.otherOptions[name] == null:\n          temp = this.otherOptions[name];\n          delete this.otherOptions[name];\n          return temp;\n\n        default:\n          return null;\n      }\n    };\n    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */\n\n\n    this.keys = function () {\n      var key;\n      return function () {\n        var results;\n        results = [];\n\n        for (key in trans) {\n          if (key != null) {\n            results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n          }\n        }\n\n        return results;\n      }().sort();\n    };\n    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */\n\n\n    this.toPlainObject = function () {\n      var hash, key, list;\n      hash = {};\n\n      for (key in trans) {\n        // @ts-ignore\n        hash[key] = trans[key].value(); // @ts-ignore\n\n        if (isObject(hash[key])) {\n          // @ts-ignore\n          hash[key] = cloneDeep(hash[key]);\n        }\n      }\n\n      if (!isEmpty(this.chained)) {\n        list = this.chained.map(tr => tr.toPlainObject());\n        list.push(hash);\n        hash = {\n          transformation: list\n        };\n      }\n\n      return hash;\n    };\n    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */\n\n\n    this.chain = function () {\n      var names, tr;\n      names = Object.getOwnPropertyNames(trans);\n\n      if (names.length !== 0) {\n        tr = new this.constructor(this.toOptions(false));\n        this.resetTransformations();\n        this.chained.push(tr);\n      }\n\n      return this;\n    };\n\n    this.resetTransformations = function () {\n      trans = {};\n      return this;\n    };\n\n    this.otherOptions = {};\n    this.chained = [];\n    this.fromOptions(options);\n  }\n  /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */\n\n\n  fromOptions(options = {}) {\n    if (options instanceof TransformationBase) {\n      this.fromTransformation(options);\n    } else {\n      if (isString(options) || Array.isArray(options)) {\n        options = {\n          transformation: options\n        };\n      }\n\n      options = cloneDeep(options); // Handling of \"if\" statements precedes other options as it creates a chained transformation\n      // @ts-ignore\n\n      if (options[\"if\"]) {\n        // @ts-ignore\n        this.set(\"if\", options[\"if\"]); // @ts-ignore\n\n        delete options[\"if\"];\n      }\n\n      for (let key in options) {\n        // @ts-ignore\n        let opt = options[key];\n\n        if (opt != null) {\n          if (key.match(VAR_NAME_RE)) {\n            if (key !== '$attr') {\n              this.set('variable', key, opt);\n            }\n          } else {\n            this.set(key, opt);\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n\n  fromTransformation(other) {\n    if (other instanceof TransformationBase) {\n      other.keys().forEach(key => this.set(key, other.get(key).origValue));\n    }\n\n    return this;\n  }\n  /**\n   * Set a parameter.\n   * The parameter name `key` is converted to\n   * @param {string} key - the name of the parameter\n   * @param {*} values - the value of the parameter\n   * @returns {Transformation} Returns this instance for chaining\n   */\n\n\n  set(key, ...values) {\n    let camelKey;\n    camelKey = camelCase(key);\n\n    if (contains(methods, camelKey)) {\n      // @ts-ignore\n      this[camelKey].apply(this, values);\n    } else {\n      this.otherOptions[key] = values[0];\n    }\n\n    return this;\n  }\n\n  hasLayer() {\n    return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n  }\n  /**\n   * Generate a string representation of the transformation.\n   * @function Transformation#serialize\n   * @return {string} Returns the transformation as a string\n   */\n\n\n  serialize() {\n    var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n    resultArray = this.chained.map(tr => tr.serialize());\n    paramList = this.keys();\n    transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n    ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n    variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n    paramList = difference(paramList, [\"transformation\", \"if\", \"variables\"]);\n    vars = [];\n    transformationList = [];\n\n    for (j = 0, len = paramList.length; j < len; j++) {\n      t = paramList[j];\n\n      if (t.match(VAR_NAME_RE)) {\n        vars.push(t + \"_\" + Expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n      } else {\n        transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n      }\n    }\n\n    switch (false) {\n      case !isString(transformations):\n        transformationList.push(transformations);\n        break;\n\n      case !Array.isArray(transformations):\n        resultArray = resultArray.concat(transformations);\n    }\n\n    transformationList = function () {\n      var k, len1, results;\n      results = [];\n\n      for (k = 0, len1 = transformationList.length; k < len1; k++) {\n        value = transformationList[k];\n\n        if (Array.isArray(value) && !isEmpty(value) || !Array.isArray(value) && value) {\n          results.push(value);\n        }\n      }\n\n      return results;\n    }();\n\n    transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n\n    if (ifParam === \"if_end\") {\n      transformationList.push(ifParam);\n    } else if (!isEmpty(ifParam)) {\n      transformationList.unshift(ifParam);\n    }\n\n    transformationString = transformationList.filter(x => !!x).join(param_separator);\n\n    if (!isEmpty(transformationString)) {\n      resultArray.push(transformationString);\n    }\n\n    return resultArray.filter(x => !!x).join(trans_separator);\n  }\n  /**\n   * Provide a list of all the valid transformation option names\n   * @function Transformation#listNames\n   * @private\n   * @return {Array<string>} a array of all the valid option names\n   */\n\n\n  static listNames() {\n    return methods;\n  }\n  /**\n   * Returns the attributes for an HTML tag.\n   * @function Cloudinary.toHtmlAttributes\n   * @return PlainObject\n   */\n\n\n  toHtmlAttributes() {\n    let attrName, height, options, ref2, ref3, value, width;\n    options = {};\n    let snakeCaseKey;\n    Object.keys(this.otherOptions).forEach(key => {\n      value = this.otherOptions[key];\n      snakeCaseKey = snakeCase(key);\n\n      if (!contains(PARAM_NAMES, snakeCaseKey) && !contains(URL_KEYS, snakeCaseKey)) {\n        attrName = /^html_/.test(key) ? key.slice(5) : key;\n        options[attrName] = value;\n      }\n    }); // convert all \"html_key\" to \"key\" with the same value\n\n    this.keys().forEach(key => {\n      if (/^html_/.test(key)) {\n        options[camelCase(key.slice(5))] = this.getValue(key);\n      }\n    });\n\n    if (!(this.hasLayer() || this.getValue(\"angle\") || contains([\"fit\", \"limit\", \"lfill\"], this.getValue(\"crop\")))) {\n      width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n      height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n\n      if (parseFloat(width) >= 1.0) {\n        if (options.width == null) {\n          options.width = width;\n        }\n      }\n\n      if (parseFloat(height) >= 1.0) {\n        if (options.height == null) {\n          options.height = height;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  static isValidParamName(name) {\n    return methods.indexOf(camelCase(name)) >= 0;\n  }\n  /**\n   * Delegate to the parent (up the call chain) to produce HTML\n   * @function Transformation#toHtml\n   * @return {string} HTML representation of the parent if possible.\n   * @example\n   * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n   * // ImageTag {name: \"img\", publicId: \"sample\"}\n   * tag.toHtml()\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n   * tag.transformation().crop(\"fit\").width(300).toHtml()\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n   */\n\n\n  toHtml() {\n    var ref;\n    return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n  }\n\n  toString() {\n    return this.serialize();\n  }\n\n  clone() {\n    return new TransformationBase(this.toOptions(true));\n  }\n\n}\n\nconst VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\nconst trans_separator = '/';\nconst param_separator = ',';\n\nfunction lastArgCallback(args) {\n  var callback;\n  callback = args != null ? args[args.length - 1] : void 0;\n\n  if (isFunction(callback)) {\n    return callback;\n  } else {\n    return void 0;\n  }\n}\n\nfunction processVar(varArray) {\n  var j, len, name, results, v;\n\n  if (Array.isArray(varArray)) {\n    results = [];\n\n    for (j = 0, len = varArray.length; j < len; j++) {\n      [name, v] = varArray[j];\n      results.push(`${name}_${Expression.normalize(v)}`);\n    }\n\n    return results;\n  } else {\n    return varArray;\n  }\n} // @ts-ignore\n\n\nfunction processCustomFunction({\n  function_type,\n  source\n}) {\n  if (function_type === 'remote') {\n    return [function_type, btoa(source)].join(\":\");\n  } else if (function_type === 'wasm') {\n    return [function_type, source].join(\":\");\n  }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */\n\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */\n\n\nclass Transformation extends TransformationBase {\n  /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */\n  constructor(options) {\n    super(options);\n  }\n  /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */\n\n\n  static new(options) {\n    return new Transformation(options);\n  }\n  /*\n    Transformation Parameters\n  */\n\n\n  angle(value) {\n    this.arrayParam(value, \"angle\", \"a\", \".\", Expression.normalize);\n    return this;\n  }\n\n  audioCodec(value) {\n    this.param(value, \"audio_codec\", \"ac\");\n    return this;\n  }\n\n  audioFrequency(value) {\n    this.param(value, \"audio_frequency\", \"af\");\n    return this;\n  }\n\n  aspectRatio(value) {\n    this.param(value, \"aspect_ratio\", \"ar\", Expression.normalize);\n    return this;\n  }\n\n  background(value) {\n    this.param(value, \"background\", \"b\", Param.norm_color);\n    return this;\n  }\n\n  bitRate(value) {\n    this.param(value, \"bit_rate\", \"br\");\n    return this;\n  }\n\n  border(value) {\n    return this.param(value, \"border\", \"bo\", border => {\n      if (isObject(border)) {\n        border = Object.assign({}, {\n          color: \"black\",\n          width: 2\n        }, border);\n        return `${border.width}px_solid_${Param.norm_color(border.color)}`;\n      } else {\n        return border;\n      }\n    });\n  }\n\n  color(value) {\n    this.param(value, \"color\", \"co\", Param.norm_color);\n    return this;\n  }\n\n  colorSpace(value) {\n    this.param(value, \"color_space\", \"cs\");\n    return this;\n  }\n\n  crop(value) {\n    this.param(value, \"crop\", \"c\");\n    return this;\n  }\n\n  customFunction(value) {\n    return this.param(value, \"custom_function\", \"fn\", () => {\n      return processCustomFunction(value);\n    });\n  }\n\n  customPreFunction(value) {\n    if (this.get('custom_function')) {\n      return;\n    }\n\n    return this.rawParam(value, \"custom_function\", \"\", () => {\n      value = processCustomFunction(value);\n      return value ? `fn_pre:${value}` : value;\n    });\n  }\n\n  defaultImage(value) {\n    this.param(value, \"default_image\", \"d\");\n    return this;\n  }\n\n  delay(value) {\n    this.param(value, \"delay\", \"dl\");\n    return this;\n  }\n\n  density(value) {\n    this.param(value, \"density\", \"dn\");\n    return this;\n  }\n\n  duration(value) {\n    this.rangeParam(value, \"duration\", \"du\");\n    return this;\n  }\n\n  dpr(value) {\n    return this.param(value, \"dpr\", \"dpr\", dpr => {\n      dpr = dpr.toString();\n\n      if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n        return dpr + \".0\";\n      } else {\n        return Expression.normalize(dpr);\n      }\n    });\n  }\n\n  effect(value) {\n    this.arrayParam(value, \"effect\", \"e\", \":\", Expression.normalize);\n    return this;\n  }\n\n  else() {\n    return this.if('else');\n  }\n\n  endIf() {\n    return this.if('end');\n  }\n\n  endOffset(value) {\n    this.rangeParam(value, \"end_offset\", \"eo\");\n    return this;\n  }\n\n  fallbackContent(value) {\n    this.param(value, \"fallback_content\");\n    return this;\n  }\n\n  fetchFormat(value) {\n    this.param(value, \"fetch_format\", \"f\");\n    return this;\n  }\n\n  format(value) {\n    this.param(value, \"format\");\n    return this;\n  }\n\n  flags(value) {\n    this.arrayParam(value, \"flags\", \"fl\", \".\");\n    return this;\n  }\n\n  gravity(value) {\n    this.param(value, \"gravity\", \"g\");\n    return this;\n  }\n\n  fps(value) {\n    return this.param(value, \"fps\", \"fps\", fps => {\n      if (isString(fps)) {\n        return fps;\n      } else if (Array.isArray(fps)) {\n        return fps.join(\"-\");\n      } else {\n        return fps;\n      }\n    });\n  }\n\n  height(value) {\n    return this.param(value, \"height\", \"h\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n  }\n\n  htmlHeight(value) {\n    this.param(value, \"html_height\");\n    return this;\n  }\n\n  htmlWidth(value) {\n    this.param(value, \"html_width\");\n    return this;\n  }\n\n  if(value = \"\") {\n    var i, ifVal, j, ref, trIf, trRest;\n\n    switch (value) {\n      case \"else\":\n        this.chain();\n        return this.param(value, \"if\", \"if\");\n\n      case \"end\":\n        this.chain();\n\n        for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {\n          ifVal = this.chained[i].getValue(\"if\");\n\n          if (ifVal === \"end\") {\n            break;\n          } else if (ifVal != null) {\n            trIf = Transformation.new().if(ifVal);\n            this.chained[i].remove(\"if\");\n            trRest = this.chained[i];\n            this.chained[i] = Transformation.new().transformation([trIf, trRest]);\n\n            if (ifVal !== \"else\") {\n              break;\n            }\n          }\n        }\n\n        return this.param(value, \"if\", \"if\");\n\n      case \"\":\n        return Condition.new().setParent(this);\n\n      default:\n        return this.param(value, \"if\", \"if\", value => {\n          return Condition.new(value).toString();\n        });\n    }\n  }\n\n  keyframeInterval(value) {\n    this.param(value, \"keyframe_interval\", \"ki\");\n    return this;\n  }\n\n  ocr(value) {\n    this.param(value, \"ocr\", \"ocr\");\n    return this;\n  }\n\n  offset(value) {\n    var end_o, start_o;\n    [start_o, end_o] = isFunction(value != null ? value.split : void 0) ? value.split('..') : Array.isArray(value) ? value : [null, null];\n\n    if (start_o != null) {\n      this.startOffset(start_o);\n    }\n\n    if (end_o != null) {\n      return this.endOffset(end_o);\n    }\n  }\n\n  opacity(value) {\n    this.param(value, \"opacity\", \"o\", Expression.normalize);\n    return this;\n  }\n\n  overlay(value) {\n    this.layerParam(value, \"overlay\", \"l\");\n    return this;\n  }\n\n  page(value) {\n    this.param(value, \"page\", \"pg\");\n    return this;\n  }\n\n  poster(value) {\n    this.param(value, \"poster\");\n    return this;\n  }\n\n  prefix(value) {\n    this.param(value, \"prefix\", \"p\");\n    return this;\n  }\n\n  quality(value) {\n    this.param(value, \"quality\", \"q\", Expression.normalize);\n    return this;\n  }\n\n  radius(value) {\n    this.arrayParam(value, \"radius\", \"r\", \":\", Expression.normalize);\n    return this;\n  }\n\n  rawTransformation(value) {\n    this.rawParam(value, \"raw_transformation\");\n    return this;\n  }\n\n  size(value) {\n    let height, width;\n\n    if (isFunction(value != null ? value.split : void 0)) {\n      [width, height] = value.split('x');\n      this.width(width);\n      return this.height(height);\n    }\n  }\n\n  sourceTypes(value) {\n    this.param(value, \"source_types\");\n    return this;\n  }\n\n  sourceTransformation(value) {\n    return this.param(value, \"source_transformation\");\n  }\n\n  startOffset(value) {\n    this.rangeParam(value, \"start_offset\", \"so\");\n    return this;\n  }\n\n  streamingProfile(value) {\n    this.param(value, \"streaming_profile\", \"sp\");\n    return this;\n  }\n\n  transformation(value) {\n    this.transformationParam(value, \"transformation\", \"t\");\n    return this;\n  }\n\n  underlay(value) {\n    this.layerParam(value, \"underlay\", \"u\");\n    return this;\n  }\n\n  variable(name, value) {\n    this.param(value, name, name);\n    return this;\n  }\n\n  variables(values) {\n    this.arrayParam(values, \"variables\");\n    return this;\n  }\n\n  videoCodec(value) {\n    this.param(value, \"video_codec\", \"vc\", Param.process_video_params);\n    return this;\n  }\n\n  videoSampling(value) {\n    this.param(value, \"video_sampling\", \"vs\");\n    return this;\n  }\n\n  width(value) {\n    this.param(value, \"width\", \"w\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n    return this;\n  }\n\n  x(value) {\n    this.param(value, \"x\", \"x\", Expression.normalize);\n    return this;\n  }\n\n  y(value) {\n    this.param(value, \"y\", \"y\", Expression.normalize);\n    return this;\n  }\n\n  zoom(value) {\n    this.param(value, \"zoom\", \"z\", Expression.normalize);\n    return this;\n  }\n\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */\n\n\nconst methods = [\"angle\", \"audioCodec\", \"audioFrequency\", \"aspectRatio\", \"background\", \"bitRate\", \"border\", \"color\", \"colorSpace\", \"crop\", \"customFunction\", \"customPreFunction\", \"defaultImage\", \"delay\", \"density\", \"duration\", \"dpr\", \"effect\", \"else\", \"endIf\", \"endOffset\", \"fallbackContent\", \"fetchFormat\", \"format\", \"flags\", \"gravity\", \"fps\", \"height\", \"htmlHeight\", \"htmlWidth\", \"if\", \"keyframeInterval\", \"ocr\", \"offset\", \"opacity\", \"overlay\", \"page\", \"poster\", \"prefix\", \"quality\", \"radius\", \"rawTransformation\", \"size\", \"sourceTypes\", \"sourceTransformation\", \"startOffset\", \"streamingProfile\", \"transformation\", \"underlay\", \"variable\", \"variables\", \"videoCodec\", \"videoSampling\", \"width\", \"x\", \"y\", \"zoom\"];\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */\n\nconst PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);\nexport default Transformation;","map":null,"metadata":{},"sourceType":"module"}