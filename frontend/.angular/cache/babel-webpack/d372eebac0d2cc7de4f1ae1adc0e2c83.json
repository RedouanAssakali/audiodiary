{"ast":null,"code":"import h from \"virtual-dom/h\";\nimport { secondsToPixels } from \"./utils/conversions\";\nimport TimeScaleHook from \"./render/TimeScaleHook\";\n\nclass TimeScale {\n  constructor(duration, offset, samplesPerPixel, sampleRate, marginLeft = 0, colors) {\n    this.duration = duration;\n    this.offset = offset;\n    this.samplesPerPixel = samplesPerPixel;\n    this.sampleRate = sampleRate;\n    this.marginLeft = marginLeft;\n    this.colors = colors;\n    this.timeinfo = {\n      20000: {\n        marker: 30000,\n        bigStep: 10000,\n        smallStep: 5000,\n        secondStep: 5\n      },\n      12000: {\n        marker: 15000,\n        bigStep: 5000,\n        smallStep: 1000,\n        secondStep: 1\n      },\n      10000: {\n        marker: 10000,\n        bigStep: 5000,\n        smallStep: 1000,\n        secondStep: 1\n      },\n      5000: {\n        marker: 5000,\n        bigStep: 1000,\n        smallStep: 500,\n        secondStep: 1 / 2\n      },\n      2500: {\n        marker: 2000,\n        bigStep: 1000,\n        smallStep: 500,\n        secondStep: 1 / 2\n      },\n      1500: {\n        marker: 2000,\n        bigStep: 1000,\n        smallStep: 200,\n        secondStep: 1 / 5\n      },\n      700: {\n        marker: 1000,\n        bigStep: 500,\n        smallStep: 100,\n        secondStep: 1 / 10\n      }\n    };\n  }\n\n  getScaleInfo(resolution) {\n    let keys = Object.keys(this.timeinfo).map(item => parseInt(item, 10)); // make sure keys are numerically sorted.\n\n    keys = keys.sort((a, b) => a - b);\n\n    for (let i = 0; i < keys.length; i += 1) {\n      if (resolution <= keys[i]) {\n        return this.timeinfo[keys[i]];\n      }\n    }\n\n    return this.timeinfo[keys[0]];\n  }\n  /*\n    Return time in format mm:ss\n  */\n\n\n  static formatTime(milliseconds) {\n    const seconds = milliseconds / 1000;\n    let s = seconds % 60;\n    const m = (seconds - s) / 60;\n\n    if (s < 10) {\n      s = `0${s}`;\n    }\n\n    return `${m}:${s}`;\n  }\n\n  render() {\n    const widthX = secondsToPixels(this.duration, this.samplesPerPixel, this.sampleRate);\n    const pixPerSec = this.sampleRate / this.samplesPerPixel;\n    const pixOffset = secondsToPixels(this.offset, this.samplesPerPixel, this.sampleRate);\n    const scaleInfo = this.getScaleInfo(this.samplesPerPixel);\n    const canvasInfo = {};\n    const timeMarkers = [];\n    const end = widthX + pixOffset;\n    let counter = 0;\n\n    for (let i = 0; i < end; i += pixPerSec * scaleInfo.secondStep) {\n      const pixIndex = Math.floor(i);\n      const pix = pixIndex - pixOffset;\n\n      if (pixIndex >= pixOffset) {\n        // put a timestamp every 30 seconds.\n        if (scaleInfo.marker && counter % scaleInfo.marker === 0) {\n          timeMarkers.push(h(\"div.time\", {\n            attributes: {\n              style: `position: absolute; left: ${pix}px;`\n            }\n          }, [TimeScale.formatTime(counter)]));\n          canvasInfo[pix] = 10;\n        } else if (scaleInfo.bigStep && counter % scaleInfo.bigStep === 0) {\n          canvasInfo[pix] = 5;\n        } else if (scaleInfo.smallStep && counter % scaleInfo.smallStep === 0) {\n          canvasInfo[pix] = 2;\n        }\n      }\n\n      counter += 1000 * scaleInfo.secondStep;\n    }\n\n    return h(\"div.playlist-time-scale\", {\n      attributes: {\n        style: `position: relative; left: 0; right: 0; margin-left: ${this.marginLeft}px;`\n      }\n    }, [timeMarkers, h(\"canvas\", {\n      attributes: {\n        width: widthX,\n        height: 30,\n        style: \"position: absolute; left: 0; right: 0; top: 0; bottom: 0;\"\n      },\n      hook: new TimeScaleHook(canvasInfo, this.offset, this.samplesPerPixel, this.duration, this.colors)\n    })]);\n  }\n\n}\n\nexport default TimeScale;","map":null,"metadata":{},"sourceType":"module"}