{"ast":null,"code":"import _assign from \"lodash.assign\";\nimport _forOwn from \"lodash.forown\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport h from \"virtual-dom/h\";\nimport extractPeaks from \"webaudio-peaks\";\nimport { FADEIN, FADEOUT } from \"fade-maker\";\nimport { secondsToPixels, secondsToSamples } from \"./utils/conversions\";\nimport stateClasses from \"./track/states\";\nimport CanvasHook from \"./render/CanvasHook\";\nimport FadeCanvasHook from \"./render/FadeCanvasHook\";\nimport VolumeSliderHook from \"./render/VolumeSliderHook\";\nimport StereoPanSliderHook from \"./render/StereoPanSliderHook\";\nconst MAX_CANVAS_WIDTH = 1000;\nexport default class {\n  constructor() {\n    this.name = \"Untitled\";\n    this.customClass = undefined;\n    this.waveOutlineColor = undefined;\n    this.gain = 1;\n    this.fades = {};\n    this.peakData = {\n      type: \"WebAudio\",\n      mono: false\n    };\n    this.cueIn = 0;\n    this.cueOut = 0;\n    this.duration = 0;\n    this.startTime = 0;\n    this.endTime = 0;\n    this.stereoPan = 0;\n  }\n\n  setEventEmitter(ee) {\n    this.ee = ee;\n  }\n\n  setName(name) {\n    this.name = name;\n  }\n\n  setCustomClass(className) {\n    this.customClass = className;\n  }\n\n  setWaveOutlineColor(color) {\n    this.waveOutlineColor = color;\n  }\n\n  setCues(cueIn, cueOut) {\n    if (cueOut < cueIn) {\n      throw new Error(\"cue out cannot be less than cue in\");\n    }\n\n    this.cueIn = cueIn;\n    this.cueOut = cueOut;\n    this.duration = this.cueOut - this.cueIn;\n    this.endTime = this.startTime + this.duration;\n  }\n  /*\n   *   start, end in seconds relative to the entire playlist.\n   */\n\n\n  trim(start, end) {\n    const trackStart = this.getStartTime();\n    const trackEnd = this.getEndTime();\n    const offset = this.cueIn - trackStart;\n\n    if (trackStart <= start && trackEnd >= start || trackStart <= end && trackEnd >= end) {\n      const cueIn = start < trackStart ? trackStart : start;\n      const cueOut = end > trackEnd ? trackEnd : end;\n      this.setCues(cueIn + offset, cueOut + offset);\n\n      if (start > trackStart) {\n        this.setStartTime(start);\n      }\n    }\n  }\n\n  setStartTime(start) {\n    this.startTime = start;\n    this.endTime = start + this.duration;\n  }\n\n  setPlayout(playout) {\n    this.playout = playout;\n  }\n\n  setOfflinePlayout(playout) {\n    this.offlinePlayout = playout;\n  }\n\n  setEnabledStates(enabledStates = {}) {\n    const defaultStatesEnabled = {\n      cursor: true,\n      fadein: true,\n      fadeout: true,\n      select: true,\n      shift: true\n    };\n    this.enabledStates = _assign({}, defaultStatesEnabled, enabledStates);\n  }\n\n  setFadeIn(duration, shape = \"logarithmic\") {\n    if (duration > this.duration) {\n      throw new Error(\"Invalid Fade In\");\n    }\n\n    const fade = {\n      shape,\n      start: 0,\n      end: duration\n    };\n\n    if (this.fadeIn) {\n      this.removeFade(this.fadeIn);\n      this.fadeIn = undefined;\n    }\n\n    this.fadeIn = this.saveFade(FADEIN, fade.shape, fade.start, fade.end);\n  }\n\n  setFadeOut(duration, shape = \"logarithmic\") {\n    if (duration > this.duration) {\n      throw new Error(\"Invalid Fade Out\");\n    }\n\n    const fade = {\n      shape,\n      start: this.duration - duration,\n      end: this.duration\n    };\n\n    if (this.fadeOut) {\n      this.removeFade(this.fadeOut);\n      this.fadeOut = undefined;\n    }\n\n    this.fadeOut = this.saveFade(FADEOUT, fade.shape, fade.start, fade.end);\n  }\n\n  saveFade(type, shape, start, end) {\n    const id = uuidv4();\n    this.fades[id] = {\n      type,\n      shape,\n      start,\n      end\n    };\n    return id;\n  }\n\n  removeFade(id) {\n    delete this.fades[id];\n  }\n\n  setBuffer(buffer) {\n    this.buffer = buffer;\n  }\n\n  setPeakData(data) {\n    this.peakData = data;\n  }\n\n  calculatePeaks(samplesPerPixel, sampleRate) {\n    const cueIn = secondsToSamples(this.cueIn, sampleRate);\n    const cueOut = secondsToSamples(this.cueOut, sampleRate);\n    this.setPeaks(extractPeaks(this.buffer, samplesPerPixel, this.peakData.mono, cueIn, cueOut));\n  }\n\n  setPeaks(peaks) {\n    this.peaks = peaks;\n  }\n\n  setState(state) {\n    this.state = state;\n\n    if (this.state && this.enabledStates[this.state]) {\n      const StateClass = stateClasses[this.state];\n      this.stateObj = new StateClass(this);\n    } else {\n      this.stateObj = undefined;\n    }\n  }\n\n  getStartTime() {\n    return this.startTime;\n  }\n\n  getEndTime() {\n    return this.endTime;\n  }\n\n  getDuration() {\n    return this.duration;\n  }\n\n  isPlaying() {\n    return this.playout.isPlaying();\n  }\n\n  setShouldPlay(bool) {\n    this.playout.setShouldPlay(bool);\n  }\n\n  setGainLevel(level) {\n    this.gain = level;\n    this.playout.setVolumeGainLevel(level);\n  }\n\n  setMasterGainLevel(level) {\n    this.playout.setMasterGainLevel(level);\n  }\n\n  setStereoPanValue(value) {\n    this.stereoPan = value;\n    this.playout.setStereoPanValue(value);\n  }\n  /*\n    startTime, endTime in seconds (float).\n    segment is for a highlighted section in the UI.\n     returns a Promise that will resolve when the AudioBufferSource\n    is either stopped or plays out naturally.\n  */\n\n\n  schedulePlay(now, startTime, endTime, config) {\n    let start;\n    let duration;\n    let when = now;\n    let segment = endTime ? endTime - startTime : undefined;\n    const defaultOptions = {\n      shouldPlay: true,\n      masterGain: 1,\n      isOffline: false\n    };\n\n    const options = _assign({}, defaultOptions, config);\n\n    const playoutSystem = options.isOffline ? this.offlinePlayout : this.playout; // 1) track has no content to play.\n    // 2) track does not play in this selection.\n\n    if (this.endTime <= startTime || segment && startTime + segment < this.startTime) {\n      // return a resolved promise since this track is technically \"stopped\".\n      return Promise.resolve();\n    } // track should have something to play if it gets here.\n    // the track starts in the future or on the cursor position\n\n\n    if (this.startTime >= startTime) {\n      start = 0; // schedule additional delay for this audio node.\n\n      when += this.startTime - startTime;\n\n      if (endTime) {\n        segment -= this.startTime - startTime;\n        duration = Math.min(segment, this.duration);\n      } else {\n        duration = this.duration;\n      }\n    } else {\n      start = startTime - this.startTime;\n\n      if (endTime) {\n        duration = Math.min(segment, this.duration - start);\n      } else {\n        duration = this.duration - start;\n      }\n    }\n\n    start += this.cueIn;\n    const relPos = startTime - this.startTime;\n    const sourcePromise = playoutSystem.setUpSource(); // param relPos: cursor position in seconds relative to this track.\n    // can be negative if the cursor is placed before the start of this track etc.\n\n    _forOwn(this.fades, fade => {\n      let fadeStart;\n      let fadeDuration; // only apply fade if it's ahead of the cursor.\n\n      if (relPos < fade.end) {\n        if (relPos <= fade.start) {\n          fadeStart = now + (fade.start - relPos);\n          fadeDuration = fade.end - fade.start;\n        } else if (relPos > fade.start && relPos < fade.end) {\n          fadeStart = now - (relPos - fade.start);\n          fadeDuration = fade.end - fade.start;\n        }\n\n        switch (fade.type) {\n          case FADEIN:\n            {\n              playoutSystem.applyFadeIn(fadeStart, fadeDuration, fade.shape);\n              break;\n            }\n\n          case FADEOUT:\n            {\n              playoutSystem.applyFadeOut(fadeStart, fadeDuration, fade.shape);\n              break;\n            }\n\n          default:\n            {\n              throw new Error(\"Invalid fade type saved on track.\");\n            }\n        }\n      }\n    });\n\n    playoutSystem.setVolumeGainLevel(this.gain);\n    playoutSystem.setShouldPlay(options.shouldPlay);\n    playoutSystem.setMasterGainLevel(options.masterGain);\n    playoutSystem.setStereoPanValue(this.stereoPan);\n    playoutSystem.play(when, start, duration);\n    return sourcePromise;\n  }\n\n  scheduleStop(when = 0) {\n    this.playout.stop(when);\n  }\n\n  renderOverlay(data) {\n    const channelPixels = secondsToPixels(data.playlistLength, data.resolution, data.sampleRate);\n    const config = {\n      attributes: {\n        style: `position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: ${channelPixels}px; z-index: 9;`\n      }\n    };\n    let overlayClass = \"\";\n\n    if (this.stateObj) {\n      this.stateObj.setup(data.resolution, data.sampleRate);\n      const StateClass = stateClasses[this.state];\n      const events = StateClass.getEvents();\n      events.forEach(event => {\n        config[`on${event}`] = this.stateObj[event].bind(this.stateObj);\n      });\n      overlayClass = StateClass.getClass();\n    } // use this overlay for track event cursor position calculations.\n\n\n    return h(`div.playlist-overlay${overlayClass}`, config);\n  }\n\n  renderControls(data) {\n    const muteClass = data.muted ? \".active\" : \"\";\n    const soloClass = data.soloed ? \".active\" : \"\";\n    const isCollapsed = data.collapsed;\n    const numChan = this.peaks.data.length;\n    const widgets = data.controls.widgets;\n    const removeTrack = h(\"button.btn.btn-danger.btn-xs.track-remove\", {\n      attributes: {\n        type: \"button\",\n        title: \"Remove track\"\n      },\n      onclick: () => {\n        this.ee.emit(\"removeTrack\", this);\n      }\n    }, [h(\"i.fas.fa-times\")]);\n    const trackName = h(\"span\", [this.name]);\n    const collapseTrack = h(\"button.btn.btn-info.btn-xs.track-collapse\", {\n      attributes: {\n        type: \"button\",\n        title: isCollapsed ? \"Expand track\" : \"Collapse track\"\n      },\n      onclick: () => {\n        this.ee.emit(\"changeTrackView\", this, {\n          collapsed: !isCollapsed\n        });\n      }\n    }, [h(`i.fas.${isCollapsed ? \"fa-caret-down\" : \"fa-caret-up\"}`)]);\n    const headerChildren = [];\n\n    if (widgets.remove) {\n      headerChildren.push(removeTrack);\n    }\n\n    headerChildren.push(trackName);\n\n    if (widgets.collapse) {\n      headerChildren.push(collapseTrack);\n    }\n\n    const controls = [h(\"div.track-header\", headerChildren)];\n\n    if (!isCollapsed) {\n      if (widgets.muteOrSolo) {\n        controls.push(h(\"div.btn-group\", [h(`button.btn.btn-outline-dark.btn-xs.btn-mute${muteClass}`, {\n          attributes: {\n            type: \"button\"\n          },\n          onclick: () => {\n            this.ee.emit(\"mute\", this);\n          }\n        }, [\"Mute\"]), h(`button.btn.btn-outline-dark.btn-xs.btn-solo${soloClass}`, {\n          onclick: () => {\n            this.ee.emit(\"solo\", this);\n          }\n        }, [\"Solo\"])]));\n      }\n\n      if (widgets.volume) {\n        controls.push(h(\"label.volume\", [h(\"input.volume-slider\", {\n          attributes: {\n            \"aria-label\": \"Track volume control\",\n            type: \"range\",\n            min: 0,\n            max: 100,\n            value: 100\n          },\n          hook: new VolumeSliderHook(this.gain),\n          oninput: e => {\n            this.ee.emit(\"volumechange\", e.target.value, this);\n          }\n        })]));\n      }\n\n      if (widgets.stereoPan) {\n        controls.push(h(\"label.stereopan\", [h(\"input.stereopan-slider\", {\n          attributes: {\n            \"aria-label\": \"Track stereo pan control\",\n            type: \"range\",\n            min: -100,\n            max: 100,\n            value: 100\n          },\n          hook: new StereoPanSliderHook(this.stereoPan),\n          oninput: e => {\n            this.ee.emit(\"stereopan\", e.target.value / 100, this);\n          }\n        })]));\n      }\n    }\n\n    return h(\"div.controls\", {\n      attributes: {\n        style: `height: ${numChan * data.height}px; width: ${data.controls.width}px; position: absolute; left: 0; z-index: 10;`\n      }\n    }, controls);\n  }\n\n  render(data) {\n    const width = this.peaks.length;\n    const playbackX = secondsToPixels(data.playbackSeconds, data.resolution, data.sampleRate);\n    const startX = secondsToPixels(this.startTime, data.resolution, data.sampleRate);\n    const endX = secondsToPixels(this.endTime, data.resolution, data.sampleRate);\n    let progressWidth = 0;\n    const numChan = this.peaks.data.length;\n    const scale = Math.floor(window.devicePixelRatio);\n\n    if (playbackX > 0 && playbackX > startX) {\n      if (playbackX < endX) {\n        progressWidth = playbackX - startX;\n      } else {\n        progressWidth = width;\n      }\n    }\n\n    const waveformChildren = [h(\"div.cursor\", {\n      attributes: {\n        style: `position: absolute; width: 1px; margin: 0; padding: 0; top: 0; left: ${playbackX}px; bottom: 0; z-index: 5;`\n      }\n    })];\n    const channels = Object.keys(this.peaks.data).map(channelNum => {\n      const channelChildren = [h(\"div.channel-progress\", {\n        attributes: {\n          style: `position: absolute; width: ${progressWidth}px; height: ${data.height}px; z-index: 2;`\n        }\n      })];\n      let offset = 0;\n      let totalWidth = width;\n      const peaks = this.peaks.data[channelNum];\n\n      while (totalWidth > 0) {\n        const currentWidth = Math.min(totalWidth, MAX_CANVAS_WIDTH);\n        const canvasColor = this.waveOutlineColor ? this.waveOutlineColor : data.colors.waveOutlineColor;\n        channelChildren.push(h(\"canvas\", {\n          attributes: {\n            width: currentWidth * scale,\n            height: data.height * scale,\n            style: `float: left; position: relative; margin: 0; padding: 0; z-index: 3; width: ${currentWidth}px; height: ${data.height}px;`\n          },\n          hook: new CanvasHook(peaks, offset, this.peaks.bits, canvasColor, scale, data.height, data.barWidth, data.barGap)\n        }));\n        totalWidth -= currentWidth;\n        offset += MAX_CANVAS_WIDTH;\n      } // if there are fades, display them.\n\n\n      if (this.fadeIn) {\n        const fadeIn = this.fades[this.fadeIn];\n        const fadeWidth = secondsToPixels(fadeIn.end - fadeIn.start, data.resolution, data.sampleRate);\n        channelChildren.push(h(\"div.wp-fade.wp-fadein\", {\n          attributes: {\n            style: `position: absolute; height: ${data.height}px; width: ${fadeWidth}px; top: 0; left: 0; z-index: 4;`\n          }\n        }, [h(\"canvas\", {\n          attributes: {\n            width: fadeWidth,\n            height: data.height\n          },\n          hook: new FadeCanvasHook(fadeIn.type, fadeIn.shape, fadeIn.end - fadeIn.start, data.resolution)\n        })]));\n      }\n\n      if (this.fadeOut) {\n        const fadeOut = this.fades[this.fadeOut];\n        const fadeWidth = secondsToPixels(fadeOut.end - fadeOut.start, data.resolution, data.sampleRate);\n        channelChildren.push(h(\"div.wp-fade.wp-fadeout\", {\n          attributes: {\n            style: `position: absolute; height: ${data.height}px; width: ${fadeWidth}px; top: 0; right: 0; z-index: 4;`\n          }\n        }, [h(\"canvas\", {\n          attributes: {\n            width: fadeWidth,\n            height: data.height\n          },\n          hook: new FadeCanvasHook(fadeOut.type, fadeOut.shape, fadeOut.end - fadeOut.start, data.resolution)\n        })]));\n      }\n\n      return h(`div.channel.channel-${channelNum}`, {\n        attributes: {\n          style: `height: ${data.height}px; width: ${width}px; top: ${channelNum * data.height}px; left: ${startX}px; position: absolute; margin: 0; padding: 0; z-index: 1;`\n        }\n      }, channelChildren);\n    });\n    waveformChildren.push(channels);\n    waveformChildren.push(this.renderOverlay(data)); // draw cursor selection on active track.\n\n    if (data.isActive === true) {\n      const cStartX = secondsToPixels(data.timeSelection.start, data.resolution, data.sampleRate);\n      const cEndX = secondsToPixels(data.timeSelection.end, data.resolution, data.sampleRate);\n      const cWidth = cEndX - cStartX + 1;\n      const cClassName = cWidth > 1 ? \".segment\" : \".point\";\n      waveformChildren.push(h(`div.selection${cClassName}`, {\n        attributes: {\n          style: `position: absolute; width: ${cWidth}px; bottom: 0; top: 0; left: ${cStartX}px; z-index: 4;`\n        }\n      }));\n    }\n\n    const waveform = h(\"div.waveform\", {\n      attributes: {\n        style: `height: ${numChan * data.height}px; position: relative;`\n      }\n    }, waveformChildren);\n    const channelChildren = [];\n    let channelMargin = 0;\n\n    if (data.controls.show) {\n      channelChildren.push(this.renderControls(data));\n      channelMargin = data.controls.width;\n    }\n\n    channelChildren.push(waveform);\n    const audibleClass = data.shouldPlay ? \"\" : \".silent\";\n    const customClass = this.customClass === undefined ? \"\" : `.${this.customClass}`;\n    return h(`div.channel-wrapper${audibleClass}${customClass}`, {\n      attributes: {\n        style: `margin-left: ${channelMargin}px; height: ${data.height * numChan}px;`\n      }\n    }, channelChildren);\n  }\n\n  getTrackDetails() {\n    const info = {\n      src: this.src,\n      start: this.startTime,\n      end: this.endTime,\n      name: this.name,\n      customClass: this.customClass,\n      cuein: this.cueIn,\n      cueout: this.cueOut,\n      stereoPan: this.stereoPan,\n      gain: this.gain\n    };\n\n    if (this.fadeIn) {\n      const fadeIn = this.fades[this.fadeIn];\n      info.fadeIn = {\n        shape: fadeIn.shape,\n        duration: fadeIn.end - fadeIn.start\n      };\n    }\n\n    if (this.fadeOut) {\n      const fadeOut = this.fades[this.fadeOut];\n      info.fadeOut = {\n        shape: fadeOut.shape,\n        duration: fadeOut.end - fadeOut.start\n      };\n    }\n\n    return info;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}