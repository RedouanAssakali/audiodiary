{"ast":null,"code":"import { FADEIN, FADEOUT, createFadeIn, createFadeOut } from \"fade-maker\";\nexport default class {\n  constructor(ac, buffer) {\n    this.ac = ac;\n    this.gain = 1;\n    this.buffer = buffer;\n    this.destination = this.ac.destination;\n    this.ac.createStereoPanner = ac.createStereoPanner || ac.createPanner;\n  }\n\n  applyFade(type, start, duration, shape = \"logarithmic\") {\n    if (type === FADEIN) {\n      createFadeIn(this.fadeGain.gain, shape, start, duration);\n    } else if (type === FADEOUT) {\n      createFadeOut(this.fadeGain.gain, shape, start, duration);\n    } else {\n      throw new Error(\"Unsupported fade type\");\n    }\n  }\n\n  applyFadeIn(start, duration, shape = \"logarithmic\") {\n    this.applyFade(FADEIN, start, duration, shape);\n  }\n\n  applyFadeOut(start, duration, shape = \"logarithmic\") {\n    this.applyFade(FADEOUT, start, duration, shape);\n  }\n\n  isPlaying() {\n    return this.source !== undefined;\n  }\n\n  getDuration() {\n    return this.buffer.duration;\n  }\n\n  setAudioContext(ac) {\n    this.ac = ac;\n    this.ac.createStereoPanner = ac.createStereoPanner || ac.createPanner;\n    this.destination = this.ac.destination;\n  }\n\n  setUpSource() {\n    this.source = this.ac.createBufferSource();\n    this.source.buffer = this.buffer;\n    const sourcePromise = new Promise(resolve => {\n      // keep track of the buffer state.\n      this.source.onended = () => {\n        this.source.disconnect();\n        this.fadeGain.disconnect();\n        this.volumeGain.disconnect();\n        this.shouldPlayGain.disconnect();\n        this.panner.disconnect();\n        this.masterGain.disconnect();\n        this.source = undefined;\n        this.fadeGain = undefined;\n        this.volumeGain = undefined;\n        this.shouldPlayGain = undefined;\n        this.panner = undefined;\n        this.masterGain = undefined;\n        resolve();\n      };\n    });\n    this.fadeGain = this.ac.createGain(); // used for track volume slider\n\n    this.volumeGain = this.ac.createGain(); // used for solo/mute\n\n    this.shouldPlayGain = this.ac.createGain();\n    this.masterGain = this.ac.createGain();\n    this.panner = this.ac.createStereoPanner();\n    this.source.connect(this.fadeGain);\n    this.fadeGain.connect(this.volumeGain);\n    this.volumeGain.connect(this.shouldPlayGain);\n    this.shouldPlayGain.connect(this.masterGain);\n    this.masterGain.connect(this.panner);\n    this.panner.connect(this.destination);\n    return sourcePromise;\n  }\n\n  setVolumeGainLevel(level) {\n    if (this.volumeGain) {\n      this.volumeGain.gain.value = level;\n    }\n  }\n\n  setShouldPlay(bool) {\n    if (this.shouldPlayGain) {\n      this.shouldPlayGain.gain.value = bool ? 1 : 0;\n    }\n  }\n\n  setMasterGainLevel(level) {\n    if (this.masterGain) {\n      this.masterGain.gain.value = level;\n    }\n  }\n\n  setStereoPanValue(value) {\n    const pan = value === undefined ? 0 : value;\n\n    if (this.panner) {\n      if (this.panner.pan !== undefined) {\n        this.panner.pan.value = pan;\n      } else {\n        this.panner.panningModel = \"equalpower\";\n        this.panner.setPosition(pan, 0, 1 - Math.abs(pan));\n      }\n    }\n  }\n  /*\n    source.start is picky when passing the end time.\n    If rounding error causes a number to make the source think\n    it is playing slightly more samples than it has it won't play at all.\n    Unfortunately it doesn't seem to work if you just give it a start time.\n  */\n\n\n  play(when, start, duration) {\n    this.source.start(when, start, duration);\n  }\n\n  stop(when = 0) {\n    if (this.source) {\n      this.source.stop(when);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}