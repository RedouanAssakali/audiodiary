{"ast":null,"code":"/*\n * virtual-dom hook for drawing to the canvas element.\n */\nclass CanvasHook {\n  constructor(peaks, offset, bits, color, scale, height, barWidth, barGap) {\n    this.peaks = peaks; // http://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element\n\n    this.offset = offset;\n    this.color = color;\n    this.bits = bits;\n    this.scale = scale;\n    this.height = height;\n    this.barWidth = barWidth;\n    this.barGap = barGap;\n  }\n\n  static drawFrame(cc, h2, x, minPeak, maxPeak, width, gap) {\n    const min = Math.abs(minPeak * h2);\n    const max = Math.abs(maxPeak * h2); // draw max\n\n    cc.fillRect(x, 0, width, h2 - max); // draw min\n\n    cc.fillRect(x, h2 + min, width, h2 - min); // draw gap\n\n    if (gap !== 0) {\n      cc.fillRect(x + width, 0, gap, h2 * 2);\n    }\n  }\n\n  hook(canvas, prop, prev) {\n    // canvas is up to date\n    if (prev !== undefined && prev.peaks === this.peaks && prev.scale === this.scale && prev.height === this.height) {\n      return;\n    }\n\n    const scale = this.scale;\n    const len = canvas.width / scale;\n    const cc = canvas.getContext(\"2d\");\n    const h2 = canvas.height / scale / 2;\n    const maxValue = 2 ** (this.bits - 1);\n    const width = this.barWidth;\n    const gap = this.barGap;\n    const barStart = width + gap;\n    cc.clearRect(0, 0, canvas.width, canvas.height);\n    cc.save();\n    cc.fillStyle = this.color;\n    cc.scale(scale, scale);\n\n    for (let pixel = 0; pixel < len; pixel += barStart) {\n      const minPeak = this.peaks[(pixel + this.offset) * 2] / maxValue;\n      const maxPeak = this.peaks[(pixel + this.offset) * 2 + 1] / maxValue;\n      CanvasHook.drawFrame(cc, h2, pixel, minPeak, maxPeak, width, gap);\n    }\n\n    cc.restore();\n  }\n\n}\n\nexport default CanvasHook;","map":null,"metadata":{},"sourceType":"module"}