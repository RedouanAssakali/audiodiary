{"ast":null,"code":"import h from \"virtual-dom/h\";\nimport inputAeneas from \"./input/aeneas\";\nimport outputAeneas from \"./output/aeneas\";\nimport { secondsToPixels } from \"../utils/conversions\";\nimport DragInteraction from \"../interaction/DragInteraction\";\nimport ScrollTopHook from \"./render/ScrollTopHook\";\nimport timeformat from \"../utils/timeformat\";\n\nclass AnnotationList {\n  constructor(playlist, annotations, controls = [], editable = false, linkEndpoints = false, isContinuousPlay = false, marginLeft = 0) {\n    this.playlist = playlist;\n    this.marginLeft = marginLeft;\n    this.resizeHandlers = [];\n    this.editable = editable;\n    this.annotations = annotations.map(a => // TODO support different formats later on.\n    inputAeneas(a));\n    this.setupInteractions();\n    this.controls = controls;\n    this.setupEE(playlist.ee); // TODO actually make a real plugin system that's not terrible.\n\n    this.playlist.isContinuousPlay = isContinuousPlay;\n    this.playlist.linkEndpoints = linkEndpoints;\n    this.length = this.annotations.length;\n  }\n\n  setupInteractions() {\n    this.annotations.forEach((a, i) => {\n      const leftShift = new DragInteraction(this.playlist, {\n        direction: \"left\",\n        index: i\n      });\n      const rightShift = new DragInteraction(this.playlist, {\n        direction: \"right\",\n        index: i\n      });\n      this.resizeHandlers.push(leftShift);\n      this.resizeHandlers.push(rightShift);\n    });\n  }\n\n  setupEE(ee) {\n    ee.on(\"dragged\", (deltaTime, data) => {\n      const annotationIndex = data.index;\n      const annotations = this.annotations;\n      const note = annotations[annotationIndex]; // resizing to the left\n\n      if (data.direction === \"left\") {\n        const originalVal = note.start;\n        note.start += deltaTime;\n\n        if (note.start < 0) {\n          note.start = 0;\n        }\n\n        if (annotationIndex && annotations[annotationIndex - 1].end > note.start) {\n          annotations[annotationIndex - 1].end = note.start;\n        }\n\n        if (this.playlist.linkEndpoints && annotationIndex && annotations[annotationIndex - 1].end === originalVal) {\n          annotations[annotationIndex - 1].end = note.start;\n        }\n      } else {\n        // resizing to the right\n        const originalVal = note.end;\n        note.end += deltaTime;\n\n        if (note.end > this.playlist.duration) {\n          note.end = this.playlist.duration;\n        }\n\n        if (annotationIndex < annotations.length - 1 && annotations[annotationIndex + 1].start < note.end) {\n          annotations[annotationIndex + 1].start = note.end;\n        }\n\n        if (this.playlist.linkEndpoints && annotationIndex < annotations.length - 1 && annotations[annotationIndex + 1].start === originalVal) {\n          annotations[annotationIndex + 1].start = note.end;\n        }\n      }\n\n      this.playlist.drawRequest();\n    });\n    ee.on(\"continuousplay\", val => {\n      this.playlist.isContinuousPlay = val;\n    });\n    ee.on(\"linkendpoints\", val => {\n      this.playlist.linkEndpoints = val;\n    });\n    ee.on(\"annotationsrequest\", () => {\n      this.export();\n    });\n    return ee;\n  }\n\n  export() {\n    const output = this.annotations.map(a => outputAeneas(a));\n    const dataStr = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(output))}`;\n    const a = document.createElement(\"a\");\n    document.body.appendChild(a);\n    a.href = dataStr;\n    a.download = \"annotations.json\";\n    a.click();\n    document.body.removeChild(a);\n  }\n\n  renderResizeLeft(i) {\n    const events = DragInteraction.getEvents();\n    const config = {\n      attributes: {\n        style: \"position: absolute; height: 30px; width: 10px; top: 0; left: -2px\",\n        draggable: true\n      }\n    };\n    const handler = this.resizeHandlers[i * 2];\n    events.forEach(event => {\n      config[`on${event}`] = handler[event].bind(handler);\n    });\n    return h(\"div.resize-handle.resize-w\", config);\n  }\n\n  renderResizeRight(i) {\n    const events = DragInteraction.getEvents();\n    const config = {\n      attributes: {\n        style: \"position: absolute; height: 30px; width: 10px; top: 0; right: -2px\",\n        draggable: true\n      }\n    };\n    const handler = this.resizeHandlers[i * 2 + 1];\n    events.forEach(event => {\n      config[`on${event}`] = handler[event].bind(handler);\n    });\n    return h(\"div.resize-handle.resize-e\", config);\n  }\n\n  renderControls(note, i) {\n    // seems to be a bug with references, or I'm missing something.\n    const that = this;\n    return this.controls.map(ctrl => h(`i.${ctrl.class}`, {\n      attributes: {\n        title: ctrl.title\n      },\n      onclick: () => {\n        ctrl.action(note, i, that.annotations, {\n          linkEndpoints: that.playlist.linkEndpoints\n        });\n        this.setupInteractions();\n        that.playlist.drawRequest();\n      }\n    }));\n  }\n\n  render() {\n    const boxes = h(\"div.annotations-boxes\", {\n      attributes: {\n        style: `height: 30px; position: relative; margin-left: ${this.marginLeft}px;`\n      }\n    }, this.annotations.map((note, i) => {\n      const samplesPerPixel = this.playlist.samplesPerPixel;\n      const sampleRate = this.playlist.sampleRate;\n      const pixPerSec = sampleRate / samplesPerPixel;\n      const pixOffset = secondsToPixels(this.playlist.scrollLeft, samplesPerPixel, sampleRate);\n      const left = Math.floor(note.start * pixPerSec - pixOffset);\n      const width = Math.ceil(note.end * pixPerSec - note.start * pixPerSec);\n      return h(\"div.annotation-box\", {\n        attributes: {\n          style: `position: absolute; height: 30px; width: ${width}px; left: ${left}px`,\n          \"data-id\": note.id\n        }\n      }, [this.renderResizeLeft(i), h(\"span.id\", {\n        onclick: () => {\n          const start = this.annotations[i].start;\n          const end = this.annotations[i].end;\n\n          if (this.playlist.isContinuousPlay) {\n            this.playlist.seek(start, start);\n            this.playlist.ee.emit(\"play\", start);\n          } else {\n            this.playlist.seek(start, end);\n            this.playlist.ee.emit(\"play\", start, end);\n          }\n        }\n      }, [note.id]), this.renderResizeRight(i)]);\n    }));\n    const boxesWrapper = h(\"div.annotations-boxes-wrapper\", {\n      attributes: {\n        style: \"overflow: hidden;\"\n      }\n    }, [boxes]);\n    const text = h(\"div.annotations-text\", {\n      hook: new ScrollTopHook()\n    }, this.annotations.map((note, i) => {\n      const format = timeformat(this.playlist.durationFormat);\n      const start = format(note.start);\n      const end = format(note.end);\n      let segmentClass = \"\";\n\n      if (this.playlist.isPlaying() && this.playlist.playbackSeconds >= note.start && this.playlist.playbackSeconds <= note.end) {\n        segmentClass = \".current\";\n      }\n\n      const editableConfig = {\n        attributes: {\n          contenteditable: true\n        },\n        oninput: e => {\n          // needed currently for references\n          // eslint-disable-next-line no-param-reassign\n          note.lines = [e.target.innerText];\n        },\n        onkeypress: e => {\n          if (e.which === 13 || e.keyCode === 13) {\n            e.target.blur();\n            e.preventDefault();\n          }\n        }\n      };\n      const linesConfig = this.editable ? editableConfig : {};\n      return h(`div.annotation${segmentClass}`, [h(\"span.annotation-id\", [note.id]), h(\"span.annotation-start\", [start]), h(\"span.annotation-end\", [end]), h(\"span.annotation-lines\", linesConfig, [note.lines]), h(\"span.annotation-actions\", this.renderControls(note, i))]);\n    }));\n    return h(\"div.annotations\", [boxesWrapper, text]);\n  }\n\n}\n\nexport default AnnotationList;","map":null,"metadata":{},"sourceType":"module"}