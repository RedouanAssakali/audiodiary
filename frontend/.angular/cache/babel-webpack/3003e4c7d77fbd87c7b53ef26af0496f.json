{"ast":null,"code":"import Layer from './layer.js';\nimport { snakeCase } from \"../utils/snakeCase.js\";\nimport { isEmpty } from \"../utils/isEmpty.js\";\nimport { smartEscape } from \"../utils/smartEscape.js\";\nimport { isNumberLike } from \"../utils/isNumberLike.js\";\n\nclass TextLayer extends Layer {\n  /**\n   * @constructor TextLayer\n   * @param {Object} options - layer parameters\n   */\n  constructor(options) {\n    let keys;\n    super(options);\n    keys = [\"resourceType\", \"resourceType\", \"fontFamily\", \"fontSize\", \"fontWeight\", \"fontStyle\", \"textDecoration\", \"textAlign\", \"stroke\", \"letterSpacing\", \"lineSpacing\", \"fontHinting\", \"fontAntialiasing\", \"text\"];\n\n    if (options != null) {\n      keys.forEach(key => {\n        var ref; // @ts-ignore\n\n        return this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n      });\n    }\n\n    this.options.resourceType = \"text\";\n  } //@ts-ignore\n\n\n  resourceType(resourceType) {\n    throw \"Cannot modify resourceType for text layers\";\n  } //@ts-ignore\n\n\n  type(type) {\n    throw \"Cannot modify type for text layers\";\n  }\n\n  format(format) {\n    throw \"Cannot modify format for text layers\";\n  }\n\n  fontFamily(fontFamily) {\n    this.options.fontFamily = fontFamily;\n    return this;\n  }\n\n  fontSize(fontSize) {\n    this.options.fontSize = fontSize;\n    return this;\n  }\n\n  fontWeight(fontWeight) {\n    this.options.fontWeight = fontWeight;\n    return this;\n  }\n\n  fontStyle(fontStyle) {\n    this.options.fontStyle = fontStyle;\n    return this;\n  }\n\n  textDecoration(textDecoration) {\n    this.options.textDecoration = textDecoration;\n    return this;\n  }\n\n  textAlign(textAlign) {\n    this.options.textAlign = textAlign;\n    return this;\n  }\n\n  stroke(stroke) {\n    this.options.stroke = stroke;\n    return this;\n  }\n\n  letterSpacing(letterSpacing) {\n    this.options.letterSpacing = letterSpacing;\n    return this;\n  }\n\n  lineSpacing(lineSpacing) {\n    this.options.lineSpacing = lineSpacing;\n    return this;\n  }\n\n  fontHinting(fontHinting) {\n    this.options.fontHinting = fontHinting;\n    return this;\n  }\n\n  fontAntialiasing(fontAntialiasing) {\n    this.options.fontAntialiasing = fontAntialiasing;\n    return this;\n  }\n\n  text(text) {\n    this.options.text = text;\n    return this;\n  }\n  /**\n   * generate the string representation of the layer\n   * @function TextLayer#toString\n   * @return {String}\n   */\n\n\n  toString() {\n    var components, hasPublicId, hasStyle, publicId, re, res, start, style, text, textSource;\n    style = this.textStyleIdentifier();\n\n    if (this.options.publicId != null) {\n      publicId = this.getFullPublicId();\n    }\n\n    if (this.options.text != null) {\n      hasPublicId = !isEmpty(publicId);\n      hasStyle = !isEmpty(style);\n\n      if (hasPublicId && hasStyle || !hasPublicId && !hasStyle) {\n        throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay, but not both!\";\n      }\n\n      re = /\\$\\([a-zA-Z]\\w*\\)/g;\n      start = 0; //        textSource = text.replace(new RegExp(\"[,/]\", 'g'), (c)-> \"%#{c.charCodeAt(0).toString(16).toUpperCase()}\")\n\n      textSource = smartEscape(this.options.text, /[,\\/]/g);\n      text = \"\";\n\n      while (res = re.exec(textSource)) {\n        text += smartEscape(textSource.slice(start, res.index));\n        text += res[0];\n        start = res.index + res[0].length;\n      }\n\n      text += smartEscape(textSource.slice(start));\n    }\n\n    components = [this.options.resourceType, style, publicId, text];\n    return components.filter(x => !!x).join(\":\");\n  }\n\n  textStyleIdentifier() {\n    var components;\n    components = [];\n\n    if (this.options.fontWeight !== \"normal\") {\n      components.push(this.options.fontWeight);\n    }\n\n    if (this.options.fontStyle !== \"normal\") {\n      components.push(this.options.fontStyle);\n    }\n\n    if (this.options.textDecoration !== \"none\") {\n      components.push(this.options.textDecoration);\n    }\n\n    components.push(this.options.textAlign);\n\n    if (this.options.stroke !== \"none\") {\n      components.push(this.options.stroke);\n    }\n\n    if (!(isEmpty(this.options.letterSpacing) && !isNumberLike(this.options.letterSpacing))) {\n      components.push(\"letter_spacing_\" + this.options.letterSpacing);\n    }\n\n    if (!(isEmpty(this.options.lineSpacing) && !isNumberLike(this.options.lineSpacing))) {\n      components.push(\"line_spacing_\" + this.options.lineSpacing);\n    }\n\n    if (!isEmpty(this.options.fontAntialiasing)) {\n      components.push(\"antialias_\" + this.options.fontAntialiasing);\n    }\n\n    if (!isEmpty(this.options.fontHinting)) {\n      components.push(\"hinting_\" + this.options.fontHinting);\n    }\n\n    if (!isEmpty(components.filter(x => !!x))) {\n      if (isEmpty(this.options.fontFamily)) {\n        throw `Must supply fontFamily. ${components}`;\n      }\n\n      if (isEmpty(this.options.fontSize) && !isNumberLike(this.options.fontSize)) {\n        throw \"Must supply fontSize.\";\n      }\n    }\n\n    components.unshift(this.options.fontFamily, this.options.fontSize);\n    components = components.filter(x => !!x).join(\"_\");\n    return components;\n  }\n\n}\n\n;\nexport default TextLayer;","map":null,"metadata":{},"sourceType":"module"}