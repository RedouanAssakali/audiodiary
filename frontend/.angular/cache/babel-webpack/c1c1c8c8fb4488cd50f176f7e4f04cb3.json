{"ast":null,"code":"var applyProperties = require(\"./apply-properties\");\n\nvar isWidget = require(\"../vnode/is-widget.js\");\n\nvar VPatch = require(\"../vnode/vpatch.js\");\n\nvar updateWidget = require(\"./update-widget\");\n\nmodule.exports = applyPatch;\n\nfunction applyPatch(vpatch, domNode, renderOptions) {\n  var type = vpatch.type;\n  var vNode = vpatch.vNode;\n  var patch = vpatch.patch;\n\n  switch (type) {\n    case VPatch.REMOVE:\n      return removeNode(domNode, vNode);\n\n    case VPatch.INSERT:\n      return insertNode(domNode, patch, renderOptions);\n\n    case VPatch.VTEXT:\n      return stringPatch(domNode, vNode, patch, renderOptions);\n\n    case VPatch.WIDGET:\n      return widgetPatch(domNode, vNode, patch, renderOptions);\n\n    case VPatch.VNODE:\n      return vNodePatch(domNode, vNode, patch, renderOptions);\n\n    case VPatch.ORDER:\n      reorderChildren(domNode, patch);\n      return domNode;\n\n    case VPatch.PROPS:\n      applyProperties(domNode, patch, vNode.properties);\n      return domNode;\n\n    case VPatch.THUNK:\n      return replaceRoot(domNode, renderOptions.patch(domNode, patch, renderOptions));\n\n    default:\n      return domNode;\n  }\n}\n\nfunction removeNode(domNode, vNode) {\n  var parentNode = domNode.parentNode;\n\n  if (parentNode) {\n    parentNode.removeChild(domNode);\n  }\n\n  destroyWidget(domNode, vNode);\n  return null;\n}\n\nfunction insertNode(parentNode, vNode, renderOptions) {\n  var newNode = renderOptions.render(vNode, renderOptions);\n\n  if (parentNode) {\n    parentNode.appendChild(newNode);\n  }\n\n  return parentNode;\n}\n\nfunction stringPatch(domNode, leftVNode, vText, renderOptions) {\n  var newNode;\n\n  if (domNode.nodeType === 3) {\n    domNode.replaceData(0, domNode.length, vText.text);\n    newNode = domNode;\n  } else {\n    var parentNode = domNode.parentNode;\n    newNode = renderOptions.render(vText, renderOptions);\n\n    if (parentNode && newNode !== domNode) {\n      parentNode.replaceChild(newNode, domNode);\n    }\n  }\n\n  return newNode;\n}\n\nfunction widgetPatch(domNode, leftVNode, widget, renderOptions) {\n  var updating = updateWidget(leftVNode, widget);\n  var newNode;\n\n  if (updating) {\n    newNode = widget.update(leftVNode, domNode) || domNode;\n  } else {\n    newNode = renderOptions.render(widget, renderOptions);\n  }\n\n  var parentNode = domNode.parentNode;\n\n  if (parentNode && newNode !== domNode) {\n    parentNode.replaceChild(newNode, domNode);\n  }\n\n  if (!updating) {\n    destroyWidget(domNode, leftVNode);\n  }\n\n  return newNode;\n}\n\nfunction vNodePatch(domNode, leftVNode, vNode, renderOptions) {\n  var parentNode = domNode.parentNode;\n  var newNode = renderOptions.render(vNode, renderOptions);\n\n  if (parentNode && newNode !== domNode) {\n    parentNode.replaceChild(newNode, domNode);\n  }\n\n  return newNode;\n}\n\nfunction destroyWidget(domNode, w) {\n  if (typeof w.destroy === \"function\" && isWidget(w)) {\n    w.destroy(domNode);\n  }\n}\n\nfunction reorderChildren(domNode, moves) {\n  var childNodes = domNode.childNodes;\n  var keyMap = {};\n  var node;\n  var remove;\n  var insert;\n\n  for (var i = 0; i < moves.removes.length; i++) {\n    remove = moves.removes[i];\n    node = childNodes[remove.from];\n\n    if (remove.key) {\n      keyMap[remove.key] = node;\n    }\n\n    domNode.removeChild(node);\n  }\n\n  var length = childNodes.length;\n\n  for (var j = 0; j < moves.inserts.length; j++) {\n    insert = moves.inserts[j];\n    node = keyMap[insert.key]; // this is the weirdest bug i've ever seen in webkit\n\n    domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to]);\n  }\n}\n\nfunction replaceRoot(oldRoot, newRoot) {\n  if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {\n    oldRoot.parentNode.replaceChild(newRoot, oldRoot);\n  }\n\n  return newRoot;\n}","map":null,"metadata":{},"sourceType":"script"}