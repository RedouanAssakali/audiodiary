{"ast":null,"code":"import { Action } from \"../../internal/Action.js\";\nimport { FlagQualifier } from \"../../qualifiers/flag/FlagQualifier.js\";\nimport { Qualifier } from \"../../internal/qualifier/Qualifier.js\";\n/**\n * @extends SDK.Action\n * @memberOf SDK\n * @description\n * A generic Layer action that can add a Video, Text or Image layer.<br>\n * This class can represent an overlay or an underlay.\n */\n\nclass LayerAction extends Action {\n  /**\n   * @description Creates a LayerAction to be used with overlays and underlays\n   * @param {ImageSource | TextSource | VideoSource} layerSource The Source used for the layer, use the builders provided {@link Qualifiers.Source|here}\n   */\n  constructor(layerSource) {\n    super();\n    this.source = layerSource;\n  }\n  /**\n   * @description Sets the layerType to 'u' (underlay) or 'l' (overlay).\n   * @param {'u' | 'l'} type\n   * @return {this}\n   */\n\n\n  setLayerType(type) {\n    this.layerType = type;\n    return this;\n  }\n  /**\n   * @description Sets the timeline position of the video layer\n   * @param {Qualifiers.TimelinePosition} timelinePosition\n   * @return {this}\n   */\n\n\n  timeline(timelinePosition) {\n    this._timelinePosition = timelinePosition;\n    return this;\n  }\n  /**\n   * @description Sets the position of the layer\n   * @param {Qualifiers.Position} position\n   * @return {this}\n   */\n\n\n  position(position) {\n    this._position = position;\n    return this;\n  }\n  /**\n   * @description Specifies how to blend the image overlay with the base overlay\n   * @param {Qualifiers.BlendMode|BlendModeType} blendMode\n   * @return {this}\n   */\n\n\n  blendMode(blendMode) {\n    this._blendMode = blendMode;\n    return this;\n  }\n  /**\n   * @private\n   * @description\n   * Closes a layer (layers are built in three stages -> /Open/Transform/Close).\n   * @return {SDK.Action}\n   */\n\n\n  closeLayer() {\n    var _a, _b, _c, _d;\n\n    const bit = new Action().addFlag(new FlagQualifier('layer_apply'));\n    (_a = this._position) === null || _a === void 0 ? void 0 : _a.qualifiers.forEach(qualifier => {\n      bit.addQualifier(qualifier);\n    }); // Flags are stored separately from qualifiers, we need to add those as well\n\n    (_b = this._position) === null || _b === void 0 ? void 0 : _b.flags.forEach(flag => {\n      bit.addFlag(flag);\n    });\n\n    if (typeof this._blendMode === \"string\") {\n      bit.addQualifier(new Qualifier('e', this._blendMode));\n    } else {\n      (_c = this._blendMode) === null || _c === void 0 ? void 0 : _c.qualifiers.forEach(qualifier => {\n        bit.addQualifier(qualifier);\n      });\n    }\n\n    (_d = this._timelinePosition) === null || _d === void 0 ? void 0 : _d.qualifiers.forEach(qualifier => {\n      bit.addQualifier(qualifier);\n    });\n    return bit;\n  }\n  /**\n   * @private\n   * @description\n   * Opens a layer (layers are built in three stages -> /Open/Transform/Close).\n   * @return string\n   */\n\n\n  openLayer() {\n    return `${this.source.getOpenSourceString(this.layerType)}`;\n  }\n  /**\n   * @description\n   * Serializes the Layer to a string\n   * @return {string}\n   */\n\n\n  toString() {\n    return [this.openLayer(), this.source.getTransformation() && this.source.getTransformation().toString(), this.closeLayer()].filter(a => a).join('/');\n  }\n\n}\n\nexport { LayerAction };","map":null,"metadata":{},"sourceType":"module"}